{"version":3,"sources":["webpack://ShaderGraph/webpack/universalModuleDefinition","webpack://ShaderGraph/./node_modules/glsl-parser/direct.js","webpack://ShaderGraph/./node_modules/glsl-parser/lib/expr.js","webpack://ShaderGraph/./node_modules/glsl-parser/lib/index.js","webpack://ShaderGraph/./node_modules/glsl-parser/lib/scope.js","webpack://ShaderGraph/./node_modules/glsl-tokenizer/index.js","webpack://ShaderGraph/./node_modules/glsl-tokenizer/lib/builtins-300es.js","webpack://ShaderGraph/./node_modules/glsl-tokenizer/lib/builtins.js","webpack://ShaderGraph/./node_modules/glsl-tokenizer/lib/literals-300es.js","webpack://ShaderGraph/./node_modules/glsl-tokenizer/lib/literals.js","webpack://ShaderGraph/./node_modules/glsl-tokenizer/lib/operators.js","webpack://ShaderGraph/./node_modules/glsl-tokenizer/string.js","webpack://ShaderGraph/./src/linker/priority.js","webpack://ShaderGraph/webpack/bootstrap","webpack://ShaderGraph/webpack/runtime/compat get default export","webpack://ShaderGraph/webpack/runtime/define property getters","webpack://ShaderGraph/webpack/runtime/hasOwnProperty shorthand","webpack://ShaderGraph/webpack/runtime/make namespace object","webpack://ShaderGraph/./src/graph/graph.js","webpack://ShaderGraph/./src/graph/outlet.js","webpack://ShaderGraph/./src/graph/node.js","webpack://ShaderGraph/./src/graph/index.js","webpack://ShaderGraph/./src/linker/snippet.js","webpack://ShaderGraph/./src/linker/assemble.js","webpack://ShaderGraph/./src/linker/program.js","webpack://ShaderGraph/./src/linker/link.js","webpack://ShaderGraph/./src/linker/layout.js","webpack://ShaderGraph/./src/linker/index.js","webpack://ShaderGraph/./src/block/block.js","webpack://ShaderGraph/./src/block/call.js","webpack://ShaderGraph/./src/block/callback.js","webpack://ShaderGraph/./src/block/isolate.js","webpack://ShaderGraph/./src/block/join.js","webpack://ShaderGraph/./src/block/index.js","webpack://ShaderGraph/./src/visualize/serialize.js","webpack://ShaderGraph/./src/factory/hash.js","webpack://ShaderGraph/./src/visualize/markup.js","webpack://ShaderGraph/./src/visualize/index.js","webpack://ShaderGraph/./src/factory/factory.js","webpack://ShaderGraph/./src/factory/material.js","webpack://ShaderGraph/./src/factory/library.js","webpack://ShaderGraph/./src/factory/queue.js","webpack://ShaderGraph/./src/factory/cache.js","webpack://ShaderGraph/./src/factory/index.js","webpack://ShaderGraph/./src/glsl/compile.js","webpack://ShaderGraph/./node_modules/three/src/math/Vector2.js","webpack://ShaderGraph/./node_modules/three/src/math/MathUtils.js","webpack://ShaderGraph/./node_modules/three/src/math/Quaternion.js","webpack://ShaderGraph/./node_modules/three/src/math/Vector3.js","webpack://ShaderGraph/./node_modules/three/src/math/Matrix3.js","webpack://ShaderGraph/./node_modules/three/src/math/Matrix4.js","webpack://ShaderGraph/./src/glsl/decl.js","webpack://ShaderGraph/./src/glsl/constants.js","webpack://ShaderGraph/./src/glsl/parse.js","webpack://ShaderGraph/./src/glsl/generate.js","webpack://ShaderGraph/./src/glsl/index.js","webpack://ShaderGraph/./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;ACVA,YAAY,mBAAO,CAAC,GAAa;;AAEjC;;AAEA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,qBAAqB;AACrB,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;;;;;;;;ACxQA;;AAEA,sBAAsB,mBAAO,CAAC,GAAQ;AACtC,YAAY,mBAAO,CAAC,GAAS;;AAE7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,4FAA4C;;AAE7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,sCAAsC;AACtC,8BAA8B;AAC9B,sCAAsC;AACtC,8BAA8B;AAC9B,4CAA4C;AAC5C,wCAAwC;AACxC,gCAAgC;AAChC,oCAAoC;AACpC,sDAAsD;AACtD,sCAAsC;AACtC,+CAA+C;AAC/C,oCAAoC;AACpC,wCAAwC;AACxC,4CAA4C;AAC5C,kCAAkC;AAClC,0BAA0B;AAC1B,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,wCAAwC,mCAAmC;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,wCAAwC,mCAAmC;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,wCAAwC,mCAAmC;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,wCAAwC,mCAAmC;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;;AAEA,kCAAkC;AAClC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,yBAAyB;AACtC,aAAa,yBAAyB;AACtC,sCAAsC;AACtC,sCAAsC;AACtC;;AAEA;AACA,gEAAgE;;AAEhE;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;;;AAGA;;AAEA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,gCAAgC;AAChC,wCAAwC,gDAAgD;AACxF;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,gCAAgC,IAAI,gBAAgB;AACpD;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kCAAkC;AAClC;AACA,oBAAoB;AACpB,yBAAyB;AACzB,oBAAoB;AACpB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,wCAAwC;AACxC;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB,oBAAoB,oBAAoB;AACxC,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA,qCAAqC,uBAAuB,gBAAgB;AAC5E,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC79BA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACrCA;;AAEA,kBAAkB,mBAAO,CAAC,GAAgB;AAC1C,gBAAgB,mBAAO,CAAC,GAAiB;AACzC,kBAAkB,mBAAO,CAAC,GAAgB;AAC1C,oBAAoB,mBAAO,CAAC,GAAsB;AAClD,oBAAoB,mBAAO,CAAC,GAAsB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB,iBAAiB,wBAAwB;AACzC;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA,gDAAgD;AAChD,8CAA8C;AAC9C,8CAA8C;AAC9C,sCAAsC;AACtC,oCAAoC;AACpC,4BAA4B;AAC5B,kCAAkC;AAClC,oCAAoC;AACpC,0CAA0C;AAC1C,kCAAkC;AAClC;;AAEA;AACA;AACA,6BAA6B,QAAQ;AACrC,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtXA;AACA,WAAW,mBAAO,CAAC,GAAY;;AAE/B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrJA,WAAW,mBAAO,CAAC,GAAY;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN;;;;;;;;AC9CA,eAAe,mBAAO,CAAC,GAAS;;AAEhC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;UCpDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,gCAAgC,YAAY;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;AAEhC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe,GAAG,KAAK;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ,qBAAqB,SAAS;AAC7D;AACA;;AAEA;AACA,uBAAuB,SAAS,qBAAqB,QAAQ;AAC7D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;AACE;;AAElC;AACA;AACA;AACO,MAAM,SAAI;AACjB;AACA;AACA;AACA;AACA,aAAa,SAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAI;;AAElB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA,SAAS;AACT;AACA,kCAAkC,MAAM;AACxC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,OAAO;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qEAAqE,IAAI;AACzE;;AAEA;AACA;;AAEA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,SAAI;;;ACpQ4B;AACzB,OAAO,UAAU,GAAG,KAAK;;AAER;AACD;AACE;;;ACLzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE,GAAG,EAAE;AACxC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACK;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mBAAmB,uBAAgB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,mBAAY;AAC5C,KAAK;AACL,oCAAoC,iBAAiB;AACrD;AACA;;AAEA;AACA;AACA;AACA,eAAe,oBAAa;;AAE5B;AACA;AACA;AACA,0BAA0B,oBAAa;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,yBAAyB,EAAQ;AACjC;AACA,KAAK,2BAA2B,GAAS;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,OAAO;;AAEb;AACA;;AAEA;AACA;;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACoC;AACE;;AAEtC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;AACK;;AAEvC;AACA;;AAEA;;AAEA;AACA;;AAEO,MAAM,SAAI;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mBAAmB,uBAAgB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,mBAAY;AAC5C,KAAK;AACL,oCAAoC,iBAAiB;AACrD;AACA;;AAEA;AACA;AACA;AACA,eAAe,oBAAa;;AAE5B;AACA;AACA;AACA,0BAA0B,oBAAa;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK,UAAU,OAAO;AAC7E;AACA;;AAEA,yBAAyB,EAAQ;AACjC;AACA,KAAK,2BAA2B,GAAS;AACzC;AACA;AACA;;AAEA;AACA;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACoC;AACN;;AAE9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,yCAAyC;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iCAAiC,yBAAyB;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAI;AACrB,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/DoC;;AAE7B,OAAO,OAAO,GAAG,OAAO;;AAEL;AACA;AACD;AACE;AACJ;AACI;;;ACT3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;AACU;;AAE5C,IAAI,WAAK;;AAEF;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,4BAA4B,SAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,WAAiB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,WAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;;AAEA,QAAQ,WAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI,WAAK;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACgC;;AAEzB,mBAAmB,KAAK;AAC/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,UAAU;;AAErB;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA,oCAAoC,iBAAiB;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;AACD;;AAEhC;AACA;AACA;AACO,uBAAuB,KAAK;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,IAAI,IAAI,KAAK;;AAElC;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;AACD;;AAEhC;AACA;AACA;AACO,sBAAsB,KAAK;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;;AAEhC;AACA;AACA;AACO,mBAAmB,KAAK;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AChDwB;AACD;AACI;AACD;AACH;;;ACJvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkC;;AAElC;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW,SAAS;AACpB,WAAW,UAAU;;AAErB;;AAEA,yBAAyB,IAAU;AACnC;AACA;AACA;AACA,KAAK,2BAA2B,QAAc;AAC9C;AACA;AACA;AACA,KAAK,2BAA2B,OAAa;AAC7C;AACA;AACA;AACA,KAAK,2BAA2B,IAAU;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,UAAU;AACV;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,OAAO;AACb;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,gBAAgB;;AAEhB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACuC;;AAEvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB,wBAAwB;AACxB,wBAAwB;AACxB,yBAAyB;AACzB,0BAA0B;AAC1B;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;;AAEtD;AACA,kCAAkC,sBAAsB;AACxD;;AAEA;AACA;;AAEA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA,oDAAoD,MAAM;AAC1D,8CAA8C,MAAM,IAAI;AACxD;AACA,QAAQ;AACR,gCAAgC,wBAAwB;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;;;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;AAClB;;AAE7B,MAAM,mBAAS,GAAG,SAAU;AAC5B,eAAe,sBAAO;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,eAAK;AACT;AACA;AACA;AACA,uBAAuB,eAAK;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEO;AACP,eAAe,eAAK;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiC;AACC;AACQ;;AAE1C;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,KAAK;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,OAAa;AAC/B,KAAK;AACL;AACA,QAAQ,OAAiB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,QAAc;AAChC,KAAK;AACL;AACA,QAAQ,OAAiB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,OAAa;AACjC,OAAO;AACP;AACA,UAAU,OAAiB;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAc;AAClC,OAAO;AACP;AACA,UAAU,OAAiB;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,IAAU;AAChC;AACA;;AAEA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,IAAU;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,OAAiB;AACvB;;AAEA;AACA;AACA,0BAA0B;AAC1B,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChdA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;AAE1C,IAAI,cAAK;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,QAAQ,cAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAiB;AACvB;AACA;AACA;AACA;AACA;;AAEA,QAAQ,cAAK;AACb;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,OAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;;AAElB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACgC;AACF;;AAEvB;AACP;AACA,eAAe,KAAK;;AAEpB;AACA;AACA,0CAA0C,IAAI;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClC0B;AACC;;AAED;AACF;AACA;AACD;;;ACNvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,wBAAwB;;AAEjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAM,YAAI;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,IAAI,GAAG,MAAM;AAC7C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9GA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,0BAA0B;AAC1B,0BAA0B;AAC1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEmB;;;AC5dnB;;AAEA,gBAAgB,SAAS;;AAEzB;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;AA4BE;;;ACjQ0C;;AAE5C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,iCAAiC;;AAEjC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kCAAkC,KAAe;;AAEjD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEsB;;;ACzpBsB;AACC;;AAE7C;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,oCAAoC;;AAEpC;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,oBAAoB,KAAe;;AAEnC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,sCAAsC,UAAU;;AAE7B;;;AChtBnB;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gBAAgB,eAAe;AAC/B,gBAAgB,eAAe;AAC/B,gBAAgB,eAAe;;AAE/B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,mBAAmB;AACvC,oBAAoB,mBAAmB;AACvC,oBAAoB,mBAAmB;;AAEvC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,cAAc;;AAE7B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;;AAEhC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gBAAgB,eAAe;AAC/B,gBAAgB,eAAe;;AAE/B;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,0BAA0B,yBAAyB;AACnD,0BAA0B,yBAAyB;;AAEnD;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;;AAEzB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,OAAO;;AAEzB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEmB;;;AClVoB;;AAEvC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,gBAAgB,eAAe,eAAe;AAC9C,gBAAgB,eAAe,eAAe;AAC9C,gBAAgB,eAAe,gBAAgB;AAC/C,gBAAgB,eAAe,gBAAgB;;AAE/C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,mBAAmB,mBAAmB;AAC1D,oBAAoB,mBAAmB,mBAAmB;AAC1D,oBAAoB,mBAAmB,qBAAqB;AAC5D,sBAAsB,qBAAqB,qBAAqB;;AAEhE;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC,iBAAiB,gBAAgB;AACjC,iBAAiB,gBAAgB;;AAEjC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,eAAe,cAAc,cAAc;AAC3C,eAAe,cAAc,cAAc;AAC3C,eAAe,cAAc,eAAe;AAC5C,eAAe,cAAc,eAAe;;AAE5C;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,gBAAgB,mBAAmB;AACnC,gBAAgB,mBAAmB;AACnC,gBAAgB,mBAAmB;;AAEnC,gBAAgB,oBAAoB;AACpC,gBAAgB,oBAAoB;AACpC,iBAAiB,qBAAqB;;AAEtC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,cAAc;;AAE7B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,aAAa,aAAa;AACxC,cAAc,aAAa,aAAa;AACxC,cAAc,aAAa,cAAc;AACzC,cAAc,aAAa,gBAAgB;;AAE3C;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,aAAa,aAAa;AAC5C,cAAc,iBAAiB,aAAa;AAC5C,cAAc,aAAa,oBAAoB;AAC/C,cAAc,aAAa,cAAc;;AAEzC;;AAEA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,QAAQ;;AAE1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,kBAAkB,QAAQ;;AAE1B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,8BAA8B,OAAO;AACrC;AACA,gCAAgC,OAAO;AACvC,+BAA+B,OAAO;AACtC,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;;AAEjB;;;ACp3BnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACA;AACA;AACA;AACA;;AAE7C;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,OAAO,EAAE,KAAK,EAAE,OAAO;AAC1E;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,+BAAO;AACzB;AACA,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClPO;AACA;;;ACDP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AACL;AACV;AACuB;;AAErD,IAAI,WAAK;;AAET;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,WAAK;AACX,WAAW,UAAI;AACf;;AAEA;AACA,mBAAmB,gBAAQ;AAC3B,UAAU,gBAAM;AAChB,GAAG;AACH,eAAe,aAAa;AAC5B;;AAEA,MAAM,WAAK;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,oCAAoC,WAAW,IAAI,KAAK;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM,WAAK;AACX,WAAW,UAAI;AACf;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,MAAM,WAAK;AACX;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,SAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;;AAEA,kBAAkB,OAAO;AACzB,kBAAkB,QAAQ;AAC1B,kBAAkB;AAClB,kBAAkB,UAAU;AAC5B,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,SAAS,CAAC,UAAU;AAC5C;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,QAAQ,IAAI,SAAS;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;;AAEjC;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAK;;AAEE;AACP,EAAE,WAAK;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA,+CAA+C,WAAK;AACpD;AACA;;AAEA;AACA;;AAEA;;AAEA,IAAI,UAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;AACD;;AAEjC;AACA;AACA;;AAEA;AACO;AACP,4BAA4B,UAAY;AACxC;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP,sBAAsB;AACtB;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACO,SAAS,eAAM;AACtB,oBAAoB,EAAE,GAAG,EAAE;AAC3B;;AAEA;AACO;AACP,YAAY,KAAK,GAAG,MAAM,GAAG,OAAO,GAAG,IAAI,KAAK,EAAE,OAAO;AACzD;;AAEA;AACO;AACP,iBAAiB,IAAI;AACrB;AACA,cAAc,IAAI,EAAE,MAAM,GAAG,KAAK;AAClC;;AAEA;AACO;AACP,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAY,kBAAkB,UAAY;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;;AAElB;AACA;AACA;AACA;AACA,WAAW,QAAQ;;AAEnB,8BAA8B,UAAY;;AAE1C;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM,KAAK,GAAG;;AAE3C;AACA;AACA,SAAS;AACT,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,GAAG;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACO;AACP,SAAS,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAM;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,QAAQ;AACd,WAAW,OAAO;AAClB,SAAS,SAAS;AAClB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA,IAAI,aAAI;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACO,MAAM,aAAI;AACjB;AACA,SAAS,yBAAyB;AAClC,SAAS,OAAO;AAChB,SAAS,QAAQ;;AAEjB;AACA;AACA,yBAAyB,eAAM;AAC/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,UAAY;;AAEnD;AACA,yBAAyB,EAAQ;AACjC;AACA;;AAEA;AACA,yBAAyB,EAAQ;AACjC;AACA;;AAEA;AACA,kBAAkB,UAAY;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;;AAEA;AACO;AACP;AACA;AACA,qEAAqE;AACrE;;AAEA;AACA,mCAAmC;AACnC;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACO;AACP;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AC/Y0B;AACF;AACG;AACC;;;ACH5B;AACA;AACA;AACA;AACA;AACA;AACgC;AACK;AACN;AACE;AACE;AACM;;AAEzC,OAAO,QAAQ,oBAAO,aAAE,GAAG,2BAAO;AAC3B,OAAO,UAAU,wBAAS,eAAE,GAAG,yBAAS;AAC/C,OAAO,QAAQ,eAAE,GAAG,sBAAM;;AAE1B,MAAM,SAAK,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,SAAK;AACvB,iBAAiB,SAAK,CAAC,WAAO,CAAC,oBAAI,YAAY,WAAO;AACtD;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,SAAK;AACzB,eAAe,OAAe,CAAC,oBAAI;AACnC;;AAEA;AACA,eAAe,QAAgB;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,WAAO;AAClB;AACA;AACA,WAAW,aAAS;AACpB;AACA;;AAEA;AACA,oBAAoB,KAAK;AACzB,sBAAsB,2BAAO;AAC7B,mBAAmB,oBAAI;AACvB,oBAAoB,yBAAK;AACzB,qBAAqB,sBAAM;AAC3B,wBAAwB,yBAAS;;AAE1B,SAAS,QAAI,sBAAsB;AAC1C;AACA","file":"shadergraph.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ShaderGraph\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ShaderGraph\"] = factory();\n\telse\n\t\troot[\"ShaderGraph\"] = factory();\n})(self, function() {\nreturn ","var parse = require('./lib/index')\r\n\r\nmodule.exports = parseArray\r\n\r\nfunction parseArray(tokens) {\r\n  var parser = parse()\r\n\r\n  for (var i = 0; i < tokens.length; i++) {\r\n    parser(tokens[i])\r\n  }\r\n\r\n  return parser(null)\r\n}\r\n","var state\r\n  , token\r\n  , tokens\r\n  , idx\r\n\r\nvar original_symbol = {\r\n    nud: function() { return this.children && this.children.length ? this : fail('unexpected')() }\r\n  , led: fail('missing operator')\r\n}\r\n\r\nvar symbol_table = {}\r\n\r\nfunction itself() {\r\n  return this\r\n}\r\n\r\nsymbol('(ident)').nud = itself\r\nsymbol('(keyword)').nud = itself\r\nsymbol('(builtin)').nud = itself\r\nsymbol('(literal)').nud = itself\r\nsymbol('(end)')\r\n\r\nsymbol(':')\r\nsymbol(';')\r\nsymbol(',')\r\nsymbol(')')\r\nsymbol(']')\r\nsymbol('}')\r\n\r\ninfixr('&&', 30)\r\ninfixr('||', 30)\r\ninfix('|', 43)\r\ninfix('^', 44)\r\ninfix('&', 45)\r\ninfix('==', 46)\r\ninfix('!=', 46)\r\ninfix('<', 47)\r\ninfix('<=', 47)\r\ninfix('>', 47)\r\ninfix('>=', 47)\r\ninfix('>>', 48)\r\ninfix('<<', 48)\r\ninfix('+', 50)\r\ninfix('-', 50)\r\ninfix('*', 60)\r\ninfix('/', 60)\r\ninfix('%', 60)\r\ninfix('?', 20, function(left) {\r\n  this.children = [left, expression(0), (advance(':'), expression(0))]\r\n  this.type = 'ternary'\r\n  return this\r\n})\r\ninfix('.', 80, function(left) {\r\n  token.type = 'literal'\r\n  state.fake(token)\r\n  this.children = [left, token]\r\n  advance()\r\n  return this\r\n})\r\ninfix('[', 80, function(left) {\r\n  this.children = [left, expression(0)]\r\n  this.type = 'binary'\r\n  advance(']')\r\n  return this\r\n})\r\ninfix('(', 80, function(left) {\r\n  this.children = [left]\r\n  this.type = 'call'\r\n\r\n  if(token.data !== ')') while(1) {\r\n    this.children.push(expression(0))\r\n    if(token.data !== ',') break\r\n    advance(',')\r\n  }\r\n  advance(')')\r\n  return this\r\n})\r\n\r\nprefix('-')\r\nprefix('+')\r\nprefix('!')\r\nprefix('~')\r\nprefix('defined')\r\nprefix('(', function() {\r\n  this.type = 'group'\r\n  this.children = [expression(0)]\r\n  advance(')')\r\n  return this\r\n})\r\nprefix('++')\r\nprefix('--')\r\nsuffix('++')\r\nsuffix('--')\r\n\r\nassignment('=')\r\nassignment('+=')\r\nassignment('-=')\r\nassignment('*=')\r\nassignment('/=')\r\nassignment('%=')\r\nassignment('&=')\r\nassignment('|=')\r\nassignment('^=')\r\nassignment('>>=')\r\nassignment('<<=')\r\n\r\nmodule.exports = function(incoming_state, incoming_tokens) {\r\n  state = incoming_state\r\n  tokens = incoming_tokens\r\n  idx = 0\r\n  var result\r\n\r\n  if(!tokens.length) return\r\n\r\n  advance()\r\n  result = expression(0)\r\n  result.parent = state[0]\r\n  emit(result)\r\n\r\n  if(idx < tokens.length) {\r\n    throw new Error('did not use all tokens')\r\n  }\r\n\r\n  result.parent.children = [result]\r\n\r\n  function emit(node) {\r\n    state.unshift(node, false)\r\n    for(var i = 0, len = node.children.length; i < len; ++i) {\r\n      emit(node.children[i])\r\n    }\r\n    state.shift()\r\n  }\r\n\r\n}\r\n\r\nfunction symbol(id, binding_power) {\r\n  var sym = symbol_table[id]\r\n  binding_power = binding_power || 0\r\n  if(sym) {\r\n    if(binding_power > sym.lbp) {\r\n      sym.lbp = binding_power\r\n    }\r\n  } else {\r\n    sym = Object.create(original_symbol)\r\n    sym.id = id\r\n    sym.lbp = binding_power\r\n    symbol_table[id] = sym\r\n  }\r\n  return sym\r\n}\r\n\r\nfunction expression(rbp) {\r\n  var left, t = token\r\n  advance()\r\n\r\n  left = t.nud()\r\n  while(rbp < token.lbp) {\r\n    t = token\r\n    advance()\r\n    left = t.led(left)\r\n  }\r\n  return left\r\n}\r\n\r\nfunction infix(id, bp, led) {\r\n  var sym = symbol(id, bp)\r\n  sym.led = led || function(left) {\r\n    this.children = [left, expression(bp)]\r\n    this.type = 'binary'\r\n    return this\r\n  }\r\n}\r\n\r\nfunction infixr(id, bp, led) {\r\n  var sym = symbol(id, bp)\r\n  sym.led = led || function(left) {\r\n    this.children = [left, expression(bp - 1)]\r\n    this.type = 'binary'\r\n    return this\r\n  }\r\n  return sym\r\n}\r\n\r\nfunction prefix(id, nud) {\r\n  var sym = symbol(id)\r\n  sym.nud = nud || function() {\r\n    this.children = [expression(70)]\r\n    this.type = 'unary'\r\n    return this\r\n  }\r\n  return sym\r\n}\r\n\r\nfunction suffix(id) {\r\n  var sym = symbol(id, 150)\r\n  sym.led = function(left) {\r\n    this.children = [left]\r\n    this.type = 'suffix'\r\n    return this\r\n  }\r\n}\r\n\r\nfunction assignment(id) {\r\n  return infixr(id, 10, function(left) {\r\n    this.children = [left, expression(9)]\r\n    this.assignment = true\r\n    this.type = 'assign'\r\n    return this\r\n  })\r\n}\r\n\r\nfunction advance(id) {\r\n  var next\r\n    , value\r\n    , type\r\n    , output\r\n\r\n  if(id && token.data !== id) {\r\n    return state.unexpected('expected `'+ id + '`, got `'+token.data+'`')\r\n  }\r\n\r\n  if(idx >= tokens.length) {\r\n    token = symbol_table['(end)']\r\n    return\r\n  }\r\n\r\n  next = tokens[idx++]\r\n  value = next.data\r\n  type = next.type\r\n\r\n  if(type === 'ident') {\r\n    output = state.scope.find(value) || state.create_node()\r\n    type = output.type\r\n  } else if(type === 'builtin') {\r\n    output = symbol_table['(builtin)']\r\n  } else if(type === 'keyword') {\r\n    output = symbol_table['(keyword)']\r\n  } else if(type === 'operator') {\r\n    output = symbol_table[value]\r\n    if(!output) {\r\n      return state.unexpected('unknown operator `'+value+'`')\r\n    }\r\n  } else if(type === 'float' || type === 'integer') {\r\n    type = 'literal'\r\n    output = symbol_table['(literal)']\r\n  } else {\r\n    return state.unexpected('unexpected token.')\r\n  }\r\n\r\n  if(output) {\r\n    if(!output.nud) { output.nud = itself }\r\n    if(!output.children) { output.children = [] }\r\n  }\r\n\r\n  output = Object.create(output)\r\n  output.token = next\r\n  output.type = type\r\n  if(!output.data) output.data = value\r\n\r\n  return token = output\r\n}\r\n\r\nfunction fail(message) {\r\n  return function() { return state.unexpected(message) }\r\n}\r\n","module.exports = parser\r\n\r\nvar full_parse_expr = require('./expr')\r\n  , Scope = require('./scope')\r\n\r\n// singleton!\r\nvar Advance = new Object\r\n\r\nvar DEBUG = false\r\n\r\nvar _ = 0\r\n  , IDENT = _++\r\n  , STMT = _++\r\n  , STMTLIST = _++\r\n  , STRUCT = _++\r\n  , FUNCTION = _++\r\n  , FUNCTIONARGS = _++\r\n  , DECL = _++\r\n  , DECLLIST = _++\r\n  , FORLOOP = _++\r\n  , WHILELOOP = _++\r\n  , IF = _++\r\n  , EXPR = _++\r\n  , PRECISION = _++\r\n  , COMMENT = _++\r\n  , PREPROCESSOR = _++\r\n  , KEYWORD = _++\r\n  , KEYWORD_OR_IDENT = _++\r\n  , RETURN = _++\r\n  , BREAK = _++\r\n  , CONTINUE = _++\r\n  , DISCARD = _++\r\n  , DOWHILELOOP = _++\r\n  , PLACEHOLDER = _++\r\n  , QUANTIFIER = _++\r\n\r\nvar DECL_ALLOW_ASSIGN = 0x1\r\n  , DECL_ALLOW_COMMA = 0x2\r\n  , DECL_REQUIRE_NAME = 0x4\r\n  , DECL_ALLOW_INVARIANT = 0x8\r\n  , DECL_ALLOW_STORAGE = 0x10\r\n  , DECL_NO_INOUT = 0x20\r\n  , DECL_ALLOW_STRUCT = 0x40\r\n  , DECL_STATEMENT = 0xFF\r\n  , DECL_FUNCTION = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_COMMA | DECL_NO_INOUT | DECL_ALLOW_INVARIANT | DECL_REQUIRE_NAME)\r\n  , DECL_STRUCT = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_INVARIANT | DECL_ALLOW_STORAGE | DECL_ALLOW_STRUCT)\r\n\r\nvar QUALIFIERS = ['const', 'attribute', 'uniform', 'varying']\r\n\r\nvar NO_ASSIGN_ALLOWED = false\r\n  , NO_COMMA_ALLOWED = false\r\n\r\n// map of tokens to stmt types\r\nvar token_map = {\r\n    'block-comment': COMMENT\r\n  , 'line-comment': COMMENT\r\n  , 'preprocessor': PREPROCESSOR\r\n}\r\n\r\n// map of stmt types to human\r\nvar stmt_type = _ = [\r\n    'ident'\r\n  , 'stmt'\r\n  , 'stmtlist'\r\n  , 'struct'\r\n  , 'function'\r\n  , 'functionargs'\r\n  , 'decl'\r\n  , 'decllist'\r\n  , 'forloop'\r\n  , 'whileloop'\r\n  , 'if'\r\n  , 'expr'\r\n  , 'precision'\r\n  , 'comment'\r\n  , 'preprocessor'\r\n  , 'keyword'\r\n  , 'keyword_or_ident'\r\n  , 'return'\r\n  , 'break'\r\n  , 'continue'\r\n  , 'discard'\r\n  , 'do-while'\r\n  , 'placeholder'\r\n  , 'quantifier'\r\n]\r\n\r\nfunction parser() {\r\n  var stmtlist = n(STMTLIST)\r\n    , stmt = n(STMT)\r\n    , decllist = n(DECLLIST)\r\n    , precision = n(PRECISION)\r\n    , ident = n(IDENT)\r\n    , keyword_or_ident = n(KEYWORD_OR_IDENT)\r\n    , fn = n(FUNCTION)\r\n    , fnargs = n(FUNCTIONARGS)\r\n    , forstmt = n(FORLOOP)\r\n    , ifstmt = n(IF)\r\n    , whilestmt = n(WHILELOOP)\r\n    , returnstmt = n(RETURN)\r\n    , dowhilestmt = n(DOWHILELOOP)\r\n    , quantifier = n(QUANTIFIER)\r\n\r\n  var parse_struct\r\n    , parse_precision\r\n    , parse_quantifier\r\n    , parse_forloop\r\n    , parse_if\r\n    , parse_return\r\n    , parse_whileloop\r\n    , parse_dowhileloop\r\n    , parse_function\r\n    , parse_function_args\r\n\r\n  var check = arguments.length ? [].slice.call(arguments) : []\r\n    , complete = false\r\n    , ended = false\r\n    , depth = 0\r\n    , state = []\r\n    , nodes = []\r\n    , tokens = []\r\n    , whitespace = []\r\n    , errored = false\r\n    , program\r\n    , token\r\n    , node\r\n\r\n  // setup state\r\n  state.shift = special_shift\r\n  state.unshift = special_unshift\r\n  state.fake = special_fake\r\n  state.unexpected = unexpected\r\n  state.scope = new Scope(state)\r\n  state.create_node = function() {\r\n    var n = mknode(IDENT, token)\r\n    n.parent = reader.program\r\n    return n\r\n  }\r\n\r\n  setup_stative_parsers()\r\n\r\n  // setup root node\r\n  node = stmtlist()\r\n  node.expecting = '(eof)'\r\n  node.mode = STMTLIST\r\n  node.token = {type: '(program)', data: '(program)'}\r\n  program = node\r\n\r\n  reader.program = program\r\n  reader.scope = function(scope) {\r\n    if(arguments.length === 1) {\r\n      state.scope = scope\r\n    }\r\n    return state.scope\r\n  }\r\n\r\n  state.unshift(node)\r\n  return reader\r\n\r\n  function reader(data) {\r\n    if (data === null) {\r\n      return end(), program\r\n    }\r\n\r\n    nodes = []\r\n    write(data)\r\n    return nodes\r\n  }\r\n\r\n  // stream functions ---------------------------------------------\r\n\r\n  function write(input) {\r\n    if(input.type === 'whitespace' || input.type === 'line-comment' || input.type === 'block-comment') {\r\n\r\n      whitespace.push(input)\r\n      return\r\n    }\r\n    tokens.push(input)\r\n    token = token || tokens[0]\r\n\r\n    if(token && whitespace.length) {\r\n      token.preceding = token.preceding || []\r\n      token.preceding = token.preceding.concat(whitespace)\r\n      whitespace = []\r\n    }\r\n\r\n    while(take()) switch(state[0].mode) {\r\n      case STMT: parse_stmt(); break\r\n      case STMTLIST: parse_stmtlist(); break\r\n      case DECL: parse_decl(); break\r\n      case DECLLIST: parse_decllist(); break\r\n      case EXPR: parse_expr(); break\r\n      case STRUCT: parse_struct(true, true); break\r\n      case PRECISION: parse_precision(); break\r\n      case IDENT: parse_ident(); break\r\n      case KEYWORD: parse_keyword(); break\r\n      case KEYWORD_OR_IDENT: parse_keyword_or_ident(); break\r\n      case FUNCTION: parse_function(); break\r\n      case FUNCTIONARGS: parse_function_args(); break\r\n      case FORLOOP: parse_forloop(); break\r\n      case WHILELOOP: parse_whileloop(); break\r\n      case DOWHILELOOP: parse_dowhileloop(); break\r\n      case RETURN: parse_return(); break\r\n      case IF: parse_if(); break\r\n      case QUANTIFIER: parse_quantifier(); break\r\n    }\r\n  }\r\n\r\n  function end(tokens) {\r\n    if(arguments.length) {\r\n      write(tokens)\r\n    }\r\n\r\n    if(state.length > 1) {\r\n      unexpected('unexpected EOF')\r\n      return\r\n    }\r\n\r\n    complete = true\r\n  }\r\n\r\n  function take() {\r\n    if(errored || !state.length)\r\n      return false\r\n\r\n    return (token = tokens[0])\r\n  }\r\n\r\n  // ----- state manipulation --------\r\n\r\n  function special_fake(x) {\r\n    state.unshift(x)\r\n    state.shift()\r\n  }\r\n\r\n  function special_unshift(_node, add_child) {\r\n    _node.parent = state[0]\r\n\r\n    var ret = [].unshift.call(this, _node)\r\n\r\n    add_child = add_child === undefined ? true : add_child\r\n\r\n    if(DEBUG) {\r\n      var pad = ''\r\n      for(var i = 0, len = this.length - 1; i < len; ++i) {\r\n        pad += ' |'\r\n      }\r\n      console.log(pad, '\\\\'+_node.type, _node.token.data)\r\n    }\r\n\r\n    if(add_child && node !== _node) node.children.push(_node)\r\n    node = _node\r\n\r\n    return ret\r\n  }\r\n\r\n  function special_shift() {\r\n    var _node = [].shift.call(this)\r\n      , okay = check[this.length]\r\n      , emit = false\r\n\r\n    if(DEBUG) {\r\n      var pad = ''\r\n      for(var i = 0, len = this.length; i < len; ++i) {\r\n        pad += ' |'\r\n      }\r\n      console.log(pad, '/'+_node.type)\r\n    }\r\n\r\n    if(check.length) {\r\n      if(typeof check[0] === 'function') {\r\n        emit = check[0](_node)\r\n      } else if(okay !== undefined) {\r\n        emit = okay.test ? okay.test(_node.type) : okay === _node.type\r\n      }\r\n    } else {\r\n      emit = true\r\n    }\r\n\r\n    if(emit && !errored) nodes.push(_node)\r\n\r\n    node = _node.parent\r\n    return _node\r\n  }\r\n\r\n  // parse states ---------------\r\n\r\n  function parse_stmtlist() {\r\n    // determine the type of the statement\r\n    // and then start parsing\r\n    return stative(\r\n      function() { state.scope.enter(); return Advance }\r\n    , normal_mode\r\n    )()\r\n\r\n    function normal_mode() {\r\n      if(token.data === state[0].expecting) {\r\n        return state.scope.exit(), state.shift()\r\n      }\r\n      switch(token.type) {\r\n        case 'preprocessor':\r\n          state.fake(adhoc())\r\n          tokens.shift()\r\n        return\r\n        default:\r\n          state.unshift(stmt())\r\n        return\r\n      }\r\n    }\r\n  }\r\n\r\n  function parse_stmt() {\r\n    if(state[0].brace) {\r\n      if(token.data !== '}') {\r\n        return unexpected('expected `}`, got '+token.data)\r\n      }\r\n      state[0].brace = false\r\n      return tokens.shift(), state.shift()\r\n    }\r\n    switch(token.type) {\r\n      case 'eof': return got_eof()\r\n      case 'keyword':\r\n        switch(token.data) {\r\n          case 'for': return state.unshift(forstmt());\r\n          case 'if': return state.unshift(ifstmt());\r\n          case 'while': return state.unshift(whilestmt());\r\n          case 'do': return state.unshift(dowhilestmt());\r\n          case 'break': return state.fake(mknode(BREAK, token)), tokens.shift()\r\n          case 'continue': return state.fake(mknode(CONTINUE, token)), tokens.shift()\r\n          case 'discard': return state.fake(mknode(DISCARD, token)), tokens.shift()\r\n          case 'return': return state.unshift(returnstmt());\r\n          case 'precision': return state.unshift(precision());\r\n        }\r\n        return state.unshift(decl(DECL_STATEMENT))\r\n      case 'ident':\r\n        var lookup\r\n        if(lookup = state.scope.find(token.data)) {\r\n          if(lookup.parent.type === 'struct') {\r\n            // this is strictly untrue, you could have an\r\n            // expr that starts with a struct constructor.\r\n            //      ... sigh\r\n            return state.unshift(decl(DECL_STATEMENT))\r\n          }\r\n          return state.unshift(expr(';'))\r\n        }\r\n      case 'operator':\r\n        if(token.data === '{') {\r\n          state[0].brace = true\r\n          var n = stmtlist()\r\n          n.expecting = '}'\r\n          return tokens.shift(), state.unshift(n)\r\n        }\r\n        if(token.data === ';') {\r\n          return tokens.shift(), state.shift()\r\n        }\r\n      default: return state.unshift(expr(';'))\r\n    }\r\n  }\r\n\r\n  function got_eof() {\r\n    if (ended) errored = true\r\n    ended = true\r\n    return state.shift()\r\n  }\r\n\r\n  function parse_decl() {\r\n    var stmt = state[0]\r\n\r\n    return stative(\r\n      invariant_or_not,\r\n      storage_or_not,\r\n      parameter_or_not,\r\n      precision_or_not,\r\n      struct_or_type,\r\n      maybe_name,\r\n      maybe_lparen,     // lparen means we're a function\r\n      is_decllist,\r\n      done\r\n    )()\r\n\r\n    function invariant_or_not() {\r\n      if(token.data === 'invariant') {\r\n        if(stmt.flags & DECL_ALLOW_INVARIANT) {\r\n          state.unshift(keyword())\r\n          return Advance\r\n        } else {\r\n          return unexpected('`invariant` is not allowed here')\r\n        }\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function storage_or_not() {\r\n      if(is_storage(token)) {\r\n        if(stmt.flags & DECL_ALLOW_STORAGE) {\r\n          state.unshift(keyword())\r\n          return Advance\r\n        } else {\r\n          return unexpected('storage is not allowed here')\r\n        }\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function parameter_or_not() {\r\n      if(is_parameter(token)) {\r\n        if(!(stmt.flags & DECL_NO_INOUT)) {\r\n          state.unshift(keyword())\r\n          return Advance\r\n        } else {\r\n          return unexpected('parameter is not allowed here')\r\n        }\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function precision_or_not() {\r\n      if(is_precision(token)) {\r\n        state.unshift(keyword())\r\n        return Advance\r\n      } else {\r\n        state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))\r\n        return Advance\r\n      }\r\n    }\r\n\r\n    function struct_or_type() {\r\n      if(token.data === 'struct') {\r\n        if(!(stmt.flags & DECL_ALLOW_STRUCT)) {\r\n          return unexpected('cannot nest structs')\r\n        }\r\n        state.unshift(struct())\r\n        return Advance\r\n      }\r\n\r\n      if(token.type === 'keyword') {\r\n        state.unshift(keyword())\r\n        return Advance\r\n      }\r\n\r\n      var lookup = state.scope.find(token.data)\r\n\r\n      if(lookup) {\r\n        state.fake(Object.create(lookup))\r\n        tokens.shift()\r\n        return Advance\r\n      }\r\n      return unexpected('expected user defined type, struct or keyword, got '+token.data)\r\n    }\r\n\r\n    function maybe_name() {\r\n      if(token.data === ',' && !(stmt.flags & DECL_ALLOW_COMMA)) {\r\n        return state.shift()\r\n      }\r\n\r\n      if(token.data === '[') {\r\n        // oh lord.\r\n        state.unshift(quantifier())\r\n        return\r\n      }\r\n\r\n      if(token.data === ')') return state.shift()\r\n\r\n      if(token.data === ';') {\r\n        return stmt.stage + 3\r\n      }\r\n\r\n      if(token.type !== 'ident' && token.type !== 'builtin') {\r\n        return unexpected('expected identifier, got '+token.data)\r\n      }\r\n\r\n      stmt.collected_name = tokens.shift()\r\n      return Advance\r\n    }\r\n\r\n    function maybe_lparen() {\r\n      if(token.data === '(') {\r\n        tokens.unshift(stmt.collected_name)\r\n        delete stmt.collected_name\r\n        state.unshift(fn())\r\n        return stmt.stage + 2\r\n      }\r\n      return Advance\r\n    }\r\n\r\n    function is_decllist() {\r\n      tokens.unshift(stmt.collected_name)\r\n      delete stmt.collected_name\r\n      state.unshift(decllist())\r\n      return Advance\r\n    }\r\n\r\n    function done() {\r\n      return state.shift()\r\n    }\r\n  }\r\n\r\n  function parse_decllist() {\r\n    // grab ident\r\n\r\n    if(token.type === 'ident' || token.type === 'builtin') {\r\n      var name = token.data\r\n      state.unshift(ident())\r\n      state.scope.define(name)\r\n      return\r\n    }\r\n\r\n    if(token.type === 'operator') {\r\n\r\n      if(token.data === ',') {\r\n        // multi-decl!\r\n        if(!(state[1].flags & DECL_ALLOW_COMMA)) {\r\n          return state.shift()\r\n        }\r\n\r\n        return tokens.shift()\r\n      } else if(token.data === '=') {\r\n        if(!(state[1].flags & DECL_ALLOW_ASSIGN)) return unexpected('`=` is not allowed here.')\r\n\r\n        tokens.shift()\r\n\r\n        state.unshift(expr(',', ';'))\r\n        return\r\n      } else if(token.data === '[') {\r\n        state.unshift(quantifier())\r\n        return\r\n      }\r\n    }\r\n    return state.shift()\r\n  }\r\n\r\n  function parse_keyword_or_ident() {\r\n    if(token.type === 'keyword') {\r\n      state[0].type = 'keyword'\r\n      state[0].mode = KEYWORD\r\n      return\r\n    }\r\n\r\n    if(token.type === 'ident') {\r\n      state[0].type = 'ident'\r\n      state[0].mode = IDENT\r\n      return\r\n    }\r\n\r\n    return unexpected('expected keyword or user-defined name, got '+token.data)\r\n  }\r\n\r\n  function parse_keyword() {\r\n    if(token.type !== 'keyword') {\r\n      return unexpected('expected keyword, got '+token.data)\r\n    }\r\n\r\n    return state.shift(), tokens.shift()\r\n  }\r\n\r\n  function parse_ident() {\r\n    if(token.type !== 'ident' && token.type !== 'builtin') {\r\n      return unexpected('expected user-defined name, got '+token.data)\r\n    }\r\n\r\n    state[0].data = token.data\r\n    return state.shift(), tokens.shift()\r\n  }\r\n\r\n\r\n  function parse_expr() {\r\n    var expecting = state[0].expecting\r\n\r\n    state[0].tokens = state[0].tokens || []\r\n\r\n    if(state[0].parenlevel === undefined) {\r\n      state[0].parenlevel = 0\r\n      state[0].bracelevel = 0\r\n    }\r\n    if(state[0].parenlevel < 1 && expecting.indexOf(token.data) > -1) {\r\n      return parseexpr(state[0].tokens)\r\n    }\r\n    if(token.data === '(') {\r\n      ++state[0].parenlevel\r\n    } else if(token.data === ')') {\r\n      --state[0].parenlevel\r\n    }\r\n\r\n    switch(token.data) {\r\n      case '{': ++state[0].bracelevel; break\r\n      case '}': --state[0].bracelevel; break\r\n      case '(': ++state[0].parenlevel; break\r\n      case ')': --state[0].parenlevel; break\r\n    }\r\n\r\n    if(state[0].parenlevel < 0) return unexpected('unexpected `)`')\r\n    if(state[0].bracelevel < 0) return unexpected('unexpected `}`')\r\n\r\n    state[0].tokens.push(tokens.shift())\r\n    return\r\n\r\n    function parseexpr(tokens) {\r\n      try {\r\n        full_parse_expr(state, tokens)\r\n      } catch(err) {\r\n        errored = true\r\n        throw err\r\n      }\r\n\r\n      return state.shift()\r\n    }\r\n  }\r\n\r\n  // node types ---------------\r\n\r\n  function n(type) {\r\n    // this is a function factory that suffices for most kinds of expressions and statements\r\n    return function() {\r\n      return mknode(type, token)\r\n    }\r\n  }\r\n\r\n  function adhoc() {\r\n    return mknode(token_map[token.type], token, node)\r\n  }\r\n\r\n  function decl(flags) {\r\n    var _ = mknode(DECL, token, node)\r\n    _.flags = flags\r\n\r\n    return _\r\n  }\r\n\r\n  function struct(allow_assign, allow_comma) {\r\n    var _ = mknode(STRUCT, token, node)\r\n    _.allow_assign = allow_assign === undefined ? true : allow_assign\r\n    _.allow_comma = allow_comma === undefined ? true : allow_comma\r\n    return _\r\n  }\r\n\r\n  function expr() {\r\n    var n = mknode(EXPR, token, node)\r\n\r\n    n.expecting = [].slice.call(arguments)\r\n    return n\r\n  }\r\n\r\n  function keyword(default_value) {\r\n    var t = token\r\n    if(default_value) {\r\n      t = {'type': '(implied)', data: '(default)', position: t.position}\r\n    }\r\n    return mknode(KEYWORD, t, node)\r\n  }\r\n\r\n  // utils ----------------------------\r\n\r\n  function unexpected(str) {\r\n    errored = true\r\n    throw new Error(\r\n      (str || 'unexpected '+state) +\r\n      ' at line '+state[0].token.line\r\n    )\r\n  }\r\n\r\n  function assert(type, data) {\r\n    return 1,\r\n      assert_null_string_or_array(type, token.type) &&\r\n      assert_null_string_or_array(data, token.data)\r\n  }\r\n\r\n  function assert_null_string_or_array(x, y) {\r\n    switch(typeof x) {\r\n      case 'string': if(y !== x) {\r\n        unexpected('expected `'+x+'`, got '+y+'\\n'+token.data);\r\n      } return !errored\r\n\r\n      case 'object': if(x && x.indexOf(y) === -1) {\r\n        unexpected('expected one of `'+x.join('`, `')+'`, got '+y);\r\n      } return !errored\r\n    }\r\n    return true\r\n  }\r\n\r\n  // stative ----------------------------\r\n\r\n  function stative() {\r\n    var steps = [].slice.call(arguments)\r\n      , step\r\n      , result\r\n\r\n    return function() {\r\n      var current = state[0]\r\n\r\n      current.stage || (current.stage = 0)\r\n\r\n      step = steps[current.stage]\r\n      if(!step) return unexpected('parser in undefined state!')\r\n\r\n      result = step()\r\n\r\n      if(result === Advance) return ++current.stage\r\n      if(result === undefined) return\r\n      current.stage = result\r\n    }\r\n  }\r\n\r\n  function advance(op, t) {\r\n    t = t || 'operator'\r\n    return function() {\r\n      if(!assert(t, op)) return\r\n\r\n      var last = tokens.shift()\r\n        , children = state[0].children\r\n        , last_node = children[children.length - 1]\r\n\r\n      if(last_node && last_node.token && last.preceding) {\r\n        last_node.token.succeeding = last_node.token.succeeding || []\r\n        last_node.token.succeeding = last_node.token.succeeding.concat(last.preceding)\r\n      }\r\n      return Advance\r\n    }\r\n  }\r\n\r\n  function advance_expr(until) {\r\n    return function() {\r\n      state.unshift(expr(until))\r\n      return Advance\r\n    }\r\n  }\r\n\r\n  function advance_ident(declare) {\r\n    return declare ? function() {\r\n      var name = token.data\r\n      return assert('ident') && (state.unshift(ident()), state.scope.define(name), Advance)\r\n    } :  function() {\r\n      if(!assert('ident')) return\r\n\r\n      var s = Object.create(state.scope.find(token.data))\r\n      s.token = token\r\n\r\n      return (tokens.shift(), Advance)\r\n    }\r\n  }\r\n\r\n  function advance_stmtlist() {\r\n    return function() {\r\n      var n = stmtlist()\r\n      n.expecting = '}'\r\n      return state.unshift(n), Advance\r\n    }\r\n  }\r\n\r\n  function maybe_stmtlist(skip) {\r\n    return function() {\r\n      var current = state[0].stage\r\n      if(token.data !== '{') { return state.unshift(stmt()), current + skip }\r\n      return tokens.shift(), Advance\r\n    }\r\n  }\r\n\r\n  function popstmt() {\r\n    return function() { return state.shift(), state.shift() }\r\n  }\r\n\r\n\r\n  function setup_stative_parsers() {\r\n\r\n    // could also be\r\n    // struct { } decllist\r\n    parse_struct =\r\n        stative(\r\n          advance('struct', 'keyword')\r\n        , function() {\r\n            if(token.data === '{') {\r\n              state.fake(mknode(IDENT, {data:'', position: token.position, type:'ident'}))\r\n              return Advance\r\n            }\r\n\r\n            return advance_ident(true)()\r\n          }\r\n        , function() { state.scope.enter(); return Advance }\r\n        , advance('{')\r\n        , function() {\r\n            if(token.type === 'preprocessor') {\r\n              state.fake(adhoc())\r\n              tokens.shift()\r\n              return\r\n            }\r\n            if(token.data === '}') {\r\n              state.scope.exit()\r\n              tokens.shift()\r\n              return state.shift()\r\n            }\r\n            if(token.data === ';') { tokens.shift(); return }\r\n            state.unshift(decl(DECL_STRUCT))\r\n          }\r\n        )\r\n\r\n    parse_precision =\r\n        stative(\r\n          function() { return tokens.shift(), Advance }\r\n        , function() {\r\n            return assert(\r\n            'keyword', ['lowp', 'mediump', 'highp']\r\n            ) && (state.unshift(keyword()), Advance)\r\n          }\r\n        , function() { return (state.unshift(keyword()), Advance) }\r\n        , function() { return state.shift() }\r\n        )\r\n\r\n    parse_quantifier =\r\n        stative(\r\n          advance('[')\r\n        , advance_expr(']')\r\n        , advance(']')\r\n        , function() { return state.shift() }\r\n        )\r\n\r\n    parse_forloop =\r\n        stative(\r\n          advance('for', 'keyword')\r\n        , advance('(')\r\n        , function() {\r\n            var lookup\r\n            if(token.type === 'ident') {\r\n              if(!(lookup = state.scope.find(token.data))) {\r\n                lookup = state.create_node()\r\n              }\r\n\r\n              if(lookup.parent.type === 'struct') {\r\n                return state.unshift(decl(DECL_STATEMENT)), Advance\r\n              }\r\n            } else if(token.type === 'builtin' || token.type === 'keyword') {\r\n              return state.unshift(decl(DECL_STATEMENT)), Advance\r\n            }\r\n            return advance_expr(';')()\r\n          }\r\n        , advance(';')\r\n        , advance_expr(';')\r\n        , advance(';')\r\n        , advance_expr(')')\r\n        , advance(')')\r\n        , maybe_stmtlist(3)\r\n        , advance_stmtlist()\r\n        , advance('}')\r\n        , popstmt()\r\n        )\r\n\r\n    parse_if =\r\n        stative(\r\n          advance('if', 'keyword')\r\n        , advance('(')\r\n        , advance_expr(')')\r\n        , advance(')')\r\n        , maybe_stmtlist(3)\r\n        , advance_stmtlist()\r\n        , advance('}')\r\n        , function() {\r\n            if(token.data === 'else') {\r\n              return tokens.shift(), state.unshift(stmt()), Advance\r\n            }\r\n            return popstmt()()\r\n          }\r\n        , popstmt()\r\n        )\r\n\r\n    parse_return =\r\n        stative(\r\n          advance('return', 'keyword')\r\n        , function() {\r\n            if(token.data === ';') return Advance\r\n            return state.unshift(expr(';')), Advance\r\n          }\r\n        , function() { tokens.shift(), popstmt()() }\r\n        )\r\n\r\n    parse_whileloop =\r\n        stative(\r\n          advance('while', 'keyword')\r\n        , advance('(')\r\n        , advance_expr(')')\r\n        , advance(')')\r\n        , maybe_stmtlist(3)\r\n        , advance_stmtlist()\r\n        , advance('}')\r\n        , popstmt()\r\n        )\r\n\r\n    parse_dowhileloop =\r\n      stative(\r\n        advance('do', 'keyword')\r\n      , maybe_stmtlist(3)\r\n      , advance_stmtlist()\r\n      , advance('}')\r\n      , advance('while', 'keyword')\r\n      , advance('(')\r\n      , advance_expr(')')\r\n      , advance(')')\r\n      , popstmt()\r\n      )\r\n\r\n    parse_function =\r\n      stative(\r\n        function() {\r\n          for(var i = 1, len = state.length; i < len; ++i) if(state[i].mode === FUNCTION) {\r\n            return unexpected('function definition is not allowed within another function')\r\n          }\r\n\r\n          return Advance\r\n        }\r\n      , function() {\r\n          if(!assert(\"ident\")) return\r\n\r\n          var name = token.data\r\n            , lookup = state.scope.find(name)\r\n\r\n          state.unshift(ident())\r\n          state.scope.define(name)\r\n\r\n          state.scope.enter(lookup ? lookup.scope : null)\r\n          return Advance\r\n        }\r\n      , advance('(')\r\n      , function() { return state.unshift(fnargs()), Advance }\r\n      , advance(')')\r\n      , function() {\r\n          // forward decl\r\n          if(token.data === ';') {\r\n            return state.scope.exit(), state.shift(), state.shift()\r\n          }\r\n          return Advance\r\n        }\r\n      , advance('{')\r\n      , advance_stmtlist()\r\n      , advance('}')\r\n      , function() { state.scope.exit(); return Advance }\r\n      , function() { return state.shift(), state.shift(), state.shift() }\r\n      )\r\n\r\n    parse_function_args =\r\n      stative(\r\n        function() {\r\n          if(token.data === 'void') { state.fake(keyword()); tokens.shift(); return Advance }\r\n          if(token.data === ')') { state.shift(); return }\r\n          if(token.data === 'struct') {\r\n            state.unshift(struct(NO_ASSIGN_ALLOWED, NO_COMMA_ALLOWED))\r\n            return Advance\r\n          }\r\n          state.unshift(decl(DECL_FUNCTION))\r\n          return Advance\r\n        }\r\n      , function() {\r\n          if(token.data === ',') { tokens.shift(); return 0 }\r\n          if(token.data === ')') { state.shift(); return }\r\n          unexpected('expected one of `,` or `)`, got '+token.data)\r\n        }\r\n      )\r\n  }\r\n}\r\n\r\nfunction mknode(mode, sourcetoken) {\r\n  return {\r\n      mode: mode\r\n    , token: sourcetoken\r\n    , children: []\r\n    , type: stmt_type[mode]\r\n    , id: (Math.random() * 0xFFFFFFFF).toString(16)\r\n  }\r\n}\r\n\r\nfunction is_storage(token) {\r\n  return token.data === 'const' ||\r\n         token.data === 'attribute' ||\r\n         token.data === 'uniform' ||\r\n         token.data === 'varying'\r\n}\r\n\r\nfunction is_parameter(token) {\r\n  return token.data === 'in' ||\r\n         token.data === 'inout' ||\r\n         token.data === 'out'\r\n}\r\n\r\nfunction is_precision(token) {\r\n  return token.data === 'highp' ||\r\n         token.data === 'mediump' ||\r\n         token.data === 'lowp'\r\n}\r\n","module.exports = scope\r\n\r\nfunction scope(state) {\r\n  if(this.constructor !== scope)\r\n    return new scope(state)\r\n\r\n  this.state = state\r\n  this.scopes = []\r\n  this.current = null\r\n}\r\n\r\nvar cons = scope\r\n  , proto = cons.prototype\r\n\r\nproto.enter = function(s) {\r\n  this.scopes.push(\r\n    this.current = this.state[0].scope = s || {}\r\n  )\r\n}\r\n\r\nproto.exit = function() {\r\n  this.scopes.pop()\r\n  this.current = this.scopes[this.scopes.length - 1]\r\n}\r\n\r\nproto.define = function(str) {\r\n  this.current[str] = this.state[0]\r\n}\r\n\r\nproto.find = function(name, fail) {\r\n  for(var i = this.scopes.length - 1; i > -1; --i) {\r\n    if(this.scopes[i].hasOwnProperty(name)) {\r\n      return this.scopes[i][name]\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n","module.exports = tokenize\r\n\r\nvar literals100 = require('./lib/literals')\r\n  , operators = require('./lib/operators')\r\n  , builtins100 = require('./lib/builtins')\r\n  , literals300es = require('./lib/literals-300es')\r\n  , builtins300es = require('./lib/builtins-300es')\r\n\r\nvar NORMAL = 999          // <-- never emitted\r\n  , TOKEN = 9999          // <-- never emitted\r\n  , BLOCK_COMMENT = 0\r\n  , LINE_COMMENT = 1\r\n  , PREPROCESSOR = 2\r\n  , OPERATOR = 3\r\n  , INTEGER = 4\r\n  , FLOAT = 5\r\n  , IDENT = 6\r\n  , BUILTIN = 7\r\n  , KEYWORD = 8\r\n  , WHITESPACE = 9\r\n  , EOF = 10\r\n  , HEX = 11\r\n\r\nvar map = [\r\n    'block-comment'\r\n  , 'line-comment'\r\n  , 'preprocessor'\r\n  , 'operator'\r\n  , 'integer'\r\n  , 'float'\r\n  , 'ident'\r\n  , 'builtin'\r\n  , 'keyword'\r\n  , 'whitespace'\r\n  , 'eof'\r\n  , 'integer'\r\n]\r\n\r\nfunction tokenize(opt) {\r\n  var i = 0\r\n    , total = 0\r\n    , mode = NORMAL\r\n    , c\r\n    , last\r\n    , content = []\r\n    , tokens = []\r\n    , token_idx = 0\r\n    , token_offs = 0\r\n    , line = 1\r\n    , col = 0\r\n    , start = 0\r\n    , isnum = false\r\n    , isoperator = false\r\n    , input = ''\r\n    , len\r\n\r\n  opt = opt || {}\r\n  var allBuiltins = builtins100\r\n  var allLiterals = literals100\r\n  if (opt.version === '300 es') {\r\n    allBuiltins = builtins300es\r\n    allLiterals = literals300es\r\n  }\r\n\r\n  // cache by name\r\n  var builtinsDict = {}, literalsDict = {}\r\n  for (var i = 0; i < allBuiltins.length; i++) {\r\n    builtinsDict[allBuiltins[i]] = true\r\n  }\r\n  for (var i = 0; i < allLiterals.length; i++) {\r\n    literalsDict[allLiterals[i]] = true\r\n  }\r\n\r\n  return function(data) {\r\n    tokens = []\r\n    if (data !== null) return write(data)\r\n    return end()\r\n  }\r\n\r\n  function token(data) {\r\n    if (data.length) {\r\n      tokens.push({\r\n        type: map[mode]\r\n      , data: data\r\n      , position: start\r\n      , line: line\r\n      , column: col\r\n      })\r\n    }\r\n  }\r\n\r\n  function write(chunk) {\r\n    i = 0\r\n\r\n    if (chunk.toString) chunk = chunk.toString()\r\n\r\n    input += chunk.replace(/\\r\\n/g, '\\n')\r\n    len = input.length\r\n\r\n\r\n    var last\r\n\r\n    while(c = input[i], i < len) {\r\n      last = i\r\n\r\n      switch(mode) {\r\n        case BLOCK_COMMENT: i = block_comment(); break\r\n        case LINE_COMMENT: i = line_comment(); break\r\n        case PREPROCESSOR: i = preprocessor(); break\r\n        case OPERATOR: i = operator(); break\r\n        case INTEGER: i = integer(); break\r\n        case HEX: i = hex(); break\r\n        case FLOAT: i = decimal(); break\r\n        case TOKEN: i = readtoken(); break\r\n        case WHITESPACE: i = whitespace(); break\r\n        case NORMAL: i = normal(); break\r\n      }\r\n\r\n      if(last !== i) {\r\n        switch(input[last]) {\r\n          case '\\n': col = 0; ++line; break\r\n          default: ++col; break\r\n        }\r\n      }\r\n    }\r\n\r\n    total += i\r\n    input = input.slice(i)\r\n    return tokens\r\n  }\r\n\r\n  function end(chunk) {\r\n    if(content.length) {\r\n      token(content.join(''))\r\n    }\r\n\r\n    mode = EOF\r\n    token('(eof)')\r\n    return tokens\r\n  }\r\n\r\n  function normal() {\r\n    content = content.length ? [] : content\r\n\r\n    if(last === '/' && c === '*') {\r\n      start = total + i - 1\r\n      mode = BLOCK_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      start = total + i - 1\r\n      mode = LINE_COMMENT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === '#') {\r\n      mode = PREPROCESSOR\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    if(/\\s/.test(c)) {\r\n      mode = WHITESPACE\r\n      start = total + i\r\n      return i\r\n    }\r\n\r\n    isnum = /\\d/.test(c)\r\n    isoperator = /[^\\w_]/.test(c)\r\n\r\n    start = total + i\r\n    mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN\r\n    return i\r\n  }\r\n\r\n  function whitespace() {\r\n    if(/[^\\s]/g.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function preprocessor() {\r\n    if((c === '\\r' || c === '\\n') && last !== '\\\\') {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function line_comment() {\r\n    return preprocessor()\r\n  }\r\n\r\n  function block_comment() {\r\n    if(c === '/' && last === '*') {\r\n      content.push(c)\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function operator() {\r\n    if(last === '.' && /\\d/.test(c)) {\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '*') {\r\n      mode = BLOCK_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(last === '/' && c === '/') {\r\n      mode = LINE_COMMENT\r\n      return i\r\n    }\r\n\r\n    if(c === '.' && content.length) {\r\n      while(determine_operator(content));\r\n\r\n      mode = FLOAT\r\n      return i\r\n    }\r\n\r\n    if(c === ';' || c === ')' || c === '(') {\r\n      if(content.length) while(determine_operator(content));\r\n      token(c)\r\n      mode = NORMAL\r\n      return i + 1\r\n    }\r\n\r\n    var is_composite_operator = content.length === 2 && c !== '='\r\n    if(/[\\w_\\d\\s]/.test(c) || is_composite_operator) {\r\n      while(determine_operator(content));\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function determine_operator(buf) {\r\n    var j = 0\r\n      , idx\r\n      , res\r\n\r\n    do {\r\n      idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))\r\n      res = operators[idx]\r\n\r\n      if(idx === -1) {\r\n        if(j-- + buf.length > 0) continue\r\n        res = buf.slice(0, 1).join('')\r\n      }\r\n\r\n      token(res)\r\n\r\n      start += res.length\r\n      content = content.slice(res.length)\r\n      return content.length\r\n    } while(1)\r\n  }\r\n\r\n  function hex() {\r\n    if(/[^a-fA-F0-9]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function integer() {\r\n    if(c === '.') {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      mode = FLOAT\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(c === 'x' && content.length === 1 && content[0] === '0') {\r\n      mode = HEX\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function decimal() {\r\n    if(c === 'f') {\r\n      content.push(c)\r\n      last = c\r\n      i += 1\r\n    }\r\n\r\n    if(/[eE]/.test(c)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if ((c === '-' || c === '+') && /[eE]/.test(last)) {\r\n      content.push(c)\r\n      last = c\r\n      return i + 1\r\n    }\r\n\r\n    if(/[^\\d]/.test(c)) {\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n\r\n  function readtoken() {\r\n    if(/[^\\d\\w_]/.test(c)) {\r\n      var contentstr = content.join('')\r\n      if(literalsDict[contentstr]) {\r\n        mode = KEYWORD\r\n      } else if(builtinsDict[contentstr]) {\r\n        mode = BUILTIN\r\n      } else {\r\n        mode = IDENT\r\n      }\r\n      token(content.join(''))\r\n      mode = NORMAL\r\n      return i\r\n    }\r\n    content.push(c)\r\n    last = c\r\n    return i + 1\r\n  }\r\n}\r\n","// 300es builtins/reserved words that were previously valid in v100\r\nvar v100 = require('./builtins')\r\n\r\n// The texture2D|Cube functions have been removed\r\n// And the gl_ features are updated\r\nv100 = v100.slice().filter(function (b) {\r\n  return !/^(gl\\_|texture)/.test(b)\r\n})\r\n\r\nmodule.exports = v100.concat([\r\n  // the updated gl_ constants\r\n    'gl_VertexID'\r\n  , 'gl_InstanceID'\r\n  , 'gl_Position'\r\n  , 'gl_PointSize'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FragDepth'\r\n  , 'gl_PointCoord'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexUniformVectors'\r\n  , 'gl_MaxVertexOutputVectors'\r\n  , 'gl_MaxFragmentInputVectors'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxFragmentUniformVectors'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MinProgramTexelOffset'\r\n  , 'gl_MaxProgramTexelOffset'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_DepthRange'\r\n\r\n  // other builtins\r\n  , 'trunc'\r\n  , 'round'\r\n  , 'roundEven'\r\n  , 'isnan'\r\n  , 'isinf'\r\n  , 'floatBitsToInt'\r\n  , 'floatBitsToUint'\r\n  , 'intBitsToFloat'\r\n  , 'uintBitsToFloat'\r\n  , 'packSnorm2x16'\r\n  , 'unpackSnorm2x16'\r\n  , 'packUnorm2x16'\r\n  , 'unpackUnorm2x16'\r\n  , 'packHalf2x16'\r\n  , 'unpackHalf2x16'\r\n  , 'outerProduct'\r\n  , 'transpose'\r\n  , 'determinant'\r\n  , 'inverse'\r\n  , 'texture'\r\n  , 'textureSize'\r\n  , 'textureProj'\r\n  , 'textureLod'\r\n  , 'textureOffset'\r\n  , 'texelFetch'\r\n  , 'texelFetchOffset'\r\n  , 'textureProjOffset'\r\n  , 'textureLodOffset'\r\n  , 'textureProjLod'\r\n  , 'textureProjLodOffset'\r\n  , 'textureGrad'\r\n  , 'textureGradOffset'\r\n  , 'textureProjGrad'\r\n  , 'textureProjGradOffset'\r\n])\r\n","module.exports = [\r\n  // Keep this list sorted\r\n  'abs'\r\n  , 'acos'\r\n  , 'all'\r\n  , 'any'\r\n  , 'asin'\r\n  , 'atan'\r\n  , 'ceil'\r\n  , 'clamp'\r\n  , 'cos'\r\n  , 'cross'\r\n  , 'dFdx'\r\n  , 'dFdy'\r\n  , 'degrees'\r\n  , 'distance'\r\n  , 'dot'\r\n  , 'equal'\r\n  , 'exp'\r\n  , 'exp2'\r\n  , 'faceforward'\r\n  , 'floor'\r\n  , 'fract'\r\n  , 'gl_BackColor'\r\n  , 'gl_BackLightModelProduct'\r\n  , 'gl_BackLightProduct'\r\n  , 'gl_BackMaterial'\r\n  , 'gl_BackSecondaryColor'\r\n  , 'gl_ClipPlane'\r\n  , 'gl_ClipVertex'\r\n  , 'gl_Color'\r\n  , 'gl_DepthRange'\r\n  , 'gl_DepthRangeParameters'\r\n  , 'gl_EyePlaneQ'\r\n  , 'gl_EyePlaneR'\r\n  , 'gl_EyePlaneS'\r\n  , 'gl_EyePlaneT'\r\n  , 'gl_Fog'\r\n  , 'gl_FogCoord'\r\n  , 'gl_FogFragCoord'\r\n  , 'gl_FogParameters'\r\n  , 'gl_FragColor'\r\n  , 'gl_FragCoord'\r\n  , 'gl_FragData'\r\n  , 'gl_FragDepth'\r\n  , 'gl_FragDepthEXT'\r\n  , 'gl_FrontColor'\r\n  , 'gl_FrontFacing'\r\n  , 'gl_FrontLightModelProduct'\r\n  , 'gl_FrontLightProduct'\r\n  , 'gl_FrontMaterial'\r\n  , 'gl_FrontSecondaryColor'\r\n  , 'gl_LightModel'\r\n  , 'gl_LightModelParameters'\r\n  , 'gl_LightModelProducts'\r\n  , 'gl_LightProducts'\r\n  , 'gl_LightSource'\r\n  , 'gl_LightSourceParameters'\r\n  , 'gl_MaterialParameters'\r\n  , 'gl_MaxClipPlanes'\r\n  , 'gl_MaxCombinedTextureImageUnits'\r\n  , 'gl_MaxDrawBuffers'\r\n  , 'gl_MaxFragmentUniformComponents'\r\n  , 'gl_MaxLights'\r\n  , 'gl_MaxTextureCoords'\r\n  , 'gl_MaxTextureImageUnits'\r\n  , 'gl_MaxTextureUnits'\r\n  , 'gl_MaxVaryingFloats'\r\n  , 'gl_MaxVertexAttribs'\r\n  , 'gl_MaxVertexTextureImageUnits'\r\n  , 'gl_MaxVertexUniformComponents'\r\n  , 'gl_ModelViewMatrix'\r\n  , 'gl_ModelViewMatrixInverse'\r\n  , 'gl_ModelViewMatrixInverseTranspose'\r\n  , 'gl_ModelViewMatrixTranspose'\r\n  , 'gl_ModelViewProjectionMatrix'\r\n  , 'gl_ModelViewProjectionMatrixInverse'\r\n  , 'gl_ModelViewProjectionMatrixInverseTranspose'\r\n  , 'gl_ModelViewProjectionMatrixTranspose'\r\n  , 'gl_MultiTexCoord0'\r\n  , 'gl_MultiTexCoord1'\r\n  , 'gl_MultiTexCoord2'\r\n  , 'gl_MultiTexCoord3'\r\n  , 'gl_MultiTexCoord4'\r\n  , 'gl_MultiTexCoord5'\r\n  , 'gl_MultiTexCoord6'\r\n  , 'gl_MultiTexCoord7'\r\n  , 'gl_Normal'\r\n  , 'gl_NormalMatrix'\r\n  , 'gl_NormalScale'\r\n  , 'gl_ObjectPlaneQ'\r\n  , 'gl_ObjectPlaneR'\r\n  , 'gl_ObjectPlaneS'\r\n  , 'gl_ObjectPlaneT'\r\n  , 'gl_Point'\r\n  , 'gl_PointCoord'\r\n  , 'gl_PointParameters'\r\n  , 'gl_PointSize'\r\n  , 'gl_Position'\r\n  , 'gl_ProjectionMatrix'\r\n  , 'gl_ProjectionMatrixInverse'\r\n  , 'gl_ProjectionMatrixInverseTranspose'\r\n  , 'gl_ProjectionMatrixTranspose'\r\n  , 'gl_SecondaryColor'\r\n  , 'gl_TexCoord'\r\n  , 'gl_TextureEnvColor'\r\n  , 'gl_TextureMatrix'\r\n  , 'gl_TextureMatrixInverse'\r\n  , 'gl_TextureMatrixInverseTranspose'\r\n  , 'gl_TextureMatrixTranspose'\r\n  , 'gl_Vertex'\r\n  , 'greaterThan'\r\n  , 'greaterThanEqual'\r\n  , 'inversesqrt'\r\n  , 'length'\r\n  , 'lessThan'\r\n  , 'lessThanEqual'\r\n  , 'log'\r\n  , 'log2'\r\n  , 'matrixCompMult'\r\n  , 'max'\r\n  , 'min'\r\n  , 'mix'\r\n  , 'mod'\r\n  , 'normalize'\r\n  , 'not'\r\n  , 'notEqual'\r\n  , 'pow'\r\n  , 'radians'\r\n  , 'reflect'\r\n  , 'refract'\r\n  , 'sign'\r\n  , 'sin'\r\n  , 'smoothstep'\r\n  , 'sqrt'\r\n  , 'step'\r\n  , 'tan'\r\n  , 'texture2D'\r\n  , 'texture2DLod'\r\n  , 'texture2DProj'\r\n  , 'texture2DProjLod'\r\n  , 'textureCube'\r\n  , 'textureCubeLod'\r\n  , 'texture2DLodEXT'\r\n  , 'texture2DProjLodEXT'\r\n  , 'textureCubeLodEXT'\r\n  , 'texture2DGradEXT'\r\n  , 'texture2DProjGradEXT'\r\n  , 'textureCubeGradEXT'\r\n]\r\n","var v100 = require('./literals')\r\n\r\nmodule.exports = v100.slice().concat([\r\n   'layout'\r\n  , 'centroid'\r\n  , 'smooth'\r\n  , 'case'\r\n  , 'mat2x2'\r\n  , 'mat2x3'\r\n  , 'mat2x4'\r\n  , 'mat3x2'\r\n  , 'mat3x3'\r\n  , 'mat3x4'\r\n  , 'mat4x2'\r\n  , 'mat4x3'\r\n  , 'mat4x4'\r\n  , 'uvec2'\r\n  , 'uvec3'\r\n  , 'uvec4'\r\n  , 'samplerCubeShadow'\r\n  , 'sampler2DArray'\r\n  , 'sampler2DArrayShadow'\r\n  , 'isampler2D'\r\n  , 'isampler3D'\r\n  , 'isamplerCube'\r\n  , 'isampler2DArray'\r\n  , 'usampler2D'\r\n  , 'usampler3D'\r\n  , 'usamplerCube'\r\n  , 'usampler2DArray'\r\n  , 'coherent'\r\n  , 'restrict'\r\n  , 'readonly'\r\n  , 'writeonly'\r\n  , 'resource'\r\n  , 'atomic_uint'\r\n  , 'noperspective'\r\n  , 'patch'\r\n  , 'sample'\r\n  , 'subroutine'\r\n  , 'common'\r\n  , 'partition'\r\n  , 'active'\r\n  , 'filter'\r\n  , 'image1D'\r\n  , 'image2D'\r\n  , 'image3D'\r\n  , 'imageCube'\r\n  , 'iimage1D'\r\n  , 'iimage2D'\r\n  , 'iimage3D'\r\n  , 'iimageCube'\r\n  , 'uimage1D'\r\n  , 'uimage2D'\r\n  , 'uimage3D'\r\n  , 'uimageCube'\r\n  , 'image1DArray'\r\n  , 'image2DArray'\r\n  , 'iimage1DArray'\r\n  , 'iimage2DArray'\r\n  , 'uimage1DArray'\r\n  , 'uimage2DArray'\r\n  , 'image1DShadow'\r\n  , 'image2DShadow'\r\n  , 'image1DArrayShadow'\r\n  , 'image2DArrayShadow'\r\n  , 'imageBuffer'\r\n  , 'iimageBuffer'\r\n  , 'uimageBuffer'\r\n  , 'sampler1DArray'\r\n  , 'sampler1DArrayShadow'\r\n  , 'isampler1D'\r\n  , 'isampler1DArray'\r\n  , 'usampler1D'\r\n  , 'usampler1DArray'\r\n  , 'isampler2DRect'\r\n  , 'usampler2DRect'\r\n  , 'samplerBuffer'\r\n  , 'isamplerBuffer'\r\n  , 'usamplerBuffer'\r\n  , 'sampler2DMS'\r\n  , 'isampler2DMS'\r\n  , 'usampler2DMS'\r\n  , 'sampler2DMSArray'\r\n  , 'isampler2DMSArray'\r\n  , 'usampler2DMSArray'\r\n])\r\n","module.exports = [\r\n  // current\r\n    'precision'\r\n  , 'highp'\r\n  , 'mediump'\r\n  , 'lowp'\r\n  , 'attribute'\r\n  , 'const'\r\n  , 'uniform'\r\n  , 'varying'\r\n  , 'break'\r\n  , 'continue'\r\n  , 'do'\r\n  , 'for'\r\n  , 'while'\r\n  , 'if'\r\n  , 'else'\r\n  , 'in'\r\n  , 'out'\r\n  , 'inout'\r\n  , 'float'\r\n  , 'int'\r\n  , 'uint'\r\n  , 'void'\r\n  , 'bool'\r\n  , 'true'\r\n  , 'false'\r\n  , 'discard'\r\n  , 'return'\r\n  , 'mat2'\r\n  , 'mat3'\r\n  , 'mat4'\r\n  , 'vec2'\r\n  , 'vec3'\r\n  , 'vec4'\r\n  , 'ivec2'\r\n  , 'ivec3'\r\n  , 'ivec4'\r\n  , 'bvec2'\r\n  , 'bvec3'\r\n  , 'bvec4'\r\n  , 'sampler1D'\r\n  , 'sampler2D'\r\n  , 'sampler3D'\r\n  , 'samplerCube'\r\n  , 'sampler1DShadow'\r\n  , 'sampler2DShadow'\r\n  , 'struct'\r\n\r\n  // future\r\n  , 'asm'\r\n  , 'class'\r\n  , 'union'\r\n  , 'enum'\r\n  , 'typedef'\r\n  , 'template'\r\n  , 'this'\r\n  , 'packed'\r\n  , 'goto'\r\n  , 'switch'\r\n  , 'default'\r\n  , 'inline'\r\n  , 'noinline'\r\n  , 'volatile'\r\n  , 'public'\r\n  , 'static'\r\n  , 'extern'\r\n  , 'external'\r\n  , 'interface'\r\n  , 'long'\r\n  , 'short'\r\n  , 'double'\r\n  , 'half'\r\n  , 'fixed'\r\n  , 'unsigned'\r\n  , 'input'\r\n  , 'output'\r\n  , 'hvec2'\r\n  , 'hvec3'\r\n  , 'hvec4'\r\n  , 'dvec2'\r\n  , 'dvec3'\r\n  , 'dvec4'\r\n  , 'fvec2'\r\n  , 'fvec3'\r\n  , 'fvec4'\r\n  , 'sampler2DRect'\r\n  , 'sampler3DRect'\r\n  , 'sampler2DRectShadow'\r\n  , 'sizeof'\r\n  , 'cast'\r\n  , 'namespace'\r\n  , 'using'\r\n]\r\n","module.exports = [\r\n    '<<='\r\n  , '>>='\r\n  , '++'\r\n  , '--'\r\n  , '<<'\r\n  , '>>'\r\n  , '<='\r\n  , '>='\r\n  , '=='\r\n  , '!='\r\n  , '&&'\r\n  , '||'\r\n  , '+='\r\n  , '-='\r\n  , '*='\r\n  , '/='\r\n  , '%='\r\n  , '&='\r\n  , '^^'\r\n  , '^='\r\n  , '|='\r\n  , '('\r\n  , ')'\r\n  , '['\r\n  , ']'\r\n  , '.'\r\n  , '!'\r\n  , '~'\r\n  , '*'\r\n  , '/'\r\n  , '%'\r\n  , '+'\r\n  , '-'\r\n  , '<'\r\n  , '>'\r\n  , '&'\r\n  , '^'\r\n  , '|'\r\n  , '?'\r\n  , ':'\r\n  , '='\r\n  , ','\r\n  , ';'\r\n  , '{'\r\n  , '}'\r\n]\r\n","var tokenize = require('./index')\r\n\r\nmodule.exports = tokenizeString\r\n\r\nfunction tokenizeString(str, opt) {\r\n  var generator = tokenize(opt)\r\n  var tokens = []\r\n\r\n  tokens = tokens.concat(generator(str))\r\n  tokens = tokens.concat(generator(null))\r\n\r\n  return tokens\r\n}\r\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS202: Simplify dynamic range loops\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nexports.make = function (x) {\n  if (x == null) {\n    x = [];\n  }\n  if (!(x instanceof Array)) {\n    x = [+x != null ? +x : 0];\n  }\n  return x;\n};\n\nexports.nest = (a, b) => a.concat(b);\n\nexports.compare = function (a, b) {\n  const n = Math.min(a.length, b.length);\n  for (\n    let i = 0, end = n, asc = 0 <= end;\n    asc ? i < end : i > end;\n    asc ? i++ : i--\n  ) {\n    const p = a[i];\n    const q = b[i];\n    if (p > q) {\n      return -1;\n    }\n    if (p < q) {\n      return 1;\n    }\n  }\n  a = a.length;\n  b = b.length;\n  if (a > b) {\n    return -1;\n  } else if (a < b) {\n    return 1;\n  } else {\n    return 0;\n  }\n};\n\nexports.max = function (a, b) {\n  if (exports.compare(a, b) > 0) {\n    return b;\n  } else {\n    return a;\n  }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS206: Consider reworking classes to avoid initClass\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n/*\n  Graph of nodes with outlets\n*/\nexport class Graph {\n  static initClass() {\n    this.index = 0;\n\n    this.IN = 0;\n    this.OUT = 1;\n  }\n  // eslint-disable-next-line no-unused-vars\n  static id(name) {\n    return ++Graph.index;\n  }\n\n  constructor(nodes, parent = null) {\n    this.parent = parent;\n    this.id = Graph.id();\n    this.nodes = [];\n    nodes && this.add(nodes);\n  }\n\n  inputs() {\n    const inputs = [];\n    for (let node of Array.from(this.nodes)) {\n      for (let outlet of Array.from(node.inputs)) {\n        if (outlet.input === null) {\n          inputs.push(outlet);\n        }\n      }\n    }\n    return inputs;\n  }\n\n  outputs() {\n    const outputs = [];\n    for (let node of Array.from(this.nodes)) {\n      for (let outlet of Array.from(node.outputs)) {\n        if (outlet.output.length === 0) {\n          outputs.push(outlet);\n        }\n      }\n    }\n    return outputs;\n  }\n\n  getIn(name) {\n    return Array.from(this.inputs()).filter(\n      (outlet) => outlet.name === name\n    )[0];\n  }\n  getOut(name) {\n    return Array.from(this.outputs()).filter(\n      (outlet) => outlet.name === name\n    )[0];\n  }\n\n  add(node, ignore) {\n    if (node.length) {\n      for (let _node of Array.from(node)) {\n        this.add(_node);\n      }\n      return;\n    }\n\n    if (node.graph && !ignore) {\n      throw new Error(\"Adding node to two graphs at once\");\n    }\n\n    node.graph = this;\n    this.nodes.push(node);\n  }\n\n  remove(node, ignore) {\n    if (node.length) {\n      for (let _node of Array.from(node)) {\n        this.remove(_node);\n      }\n      return;\n    }\n\n    if (node.graph !== this) {\n      throw new Error(\"Removing node from wrong graph.\");\n    }\n\n    ignore || node.disconnect();\n\n    this.nodes.splice(this.nodes.indexOf(node), 1);\n    node.graph = null;\n  }\n\n  adopt(node) {\n    if (node.length) {\n      for (let _node of Array.from(node)) {\n        this.adopt(_node);\n      }\n      return;\n    }\n\n    node.graph.remove(node, true);\n    this.add(node, true);\n  }\n}\nGraph.initClass();\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Graph } from \"./graph\";\n\n/*\n  In/out outlet on node\n*/\nexport class Outlet {\n  static initClass() {\n    this.index = 0;\n  }\n  static make(outlet, extra) {\n    if (extra == null) {\n      extra = {};\n    }\n    const meta = extra;\n    if (outlet.meta != null) {\n      for (let key in outlet.meta) {\n        const value = outlet.meta[key];\n        meta[key] = value;\n      }\n    }\n    return new Outlet(\n      outlet.inout,\n      outlet.name,\n      outlet.hint,\n      outlet.type,\n      meta\n    );\n  }\n  static id(name) {\n    return `_io_${++Outlet.index}_${name}`;\n  }\n\n  static hint(name) {\n    name = name.replace(/^_io_[0-9]+_/, \"\");\n    name = name.replace(/_i_o$/, \"\");\n    return (name = name.replace(/(In|Out|Inout|InOut)$/, \"\"));\n  }\n\n  constructor(inout, name, hint, type, meta, id) {\n    this.inout = inout;\n    this.name = name;\n    this.hint = hint;\n    this.type = type;\n    if (meta == null) {\n      meta = {};\n    }\n    this.meta = meta;\n    this.id = id;\n    if (this.hint == null) {\n      this.hint = Outlet.hint(this.name);\n    }\n\n    this.node = null;\n    this.input = null;\n    this.output = [];\n    if (this.id == null) {\n      this.id = Outlet.id(this.hint);\n    }\n  }\n\n  // Change into given outlet without touching connections\n  morph(outlet) {\n    this.inout = outlet.inout;\n    this.name = outlet.name;\n    this.hint = outlet.hint;\n    this.type = outlet.type;\n    return (this.meta = outlet.meta);\n  }\n\n  // Copy with unique name and cloned metadata\n  dupe(name) {\n    if (name == null) {\n      name = this.id;\n    }\n    const outlet = Outlet.make(this);\n    outlet.name = name;\n    return outlet;\n  }\n\n  // Connect to given outlet\n  connect(outlet) {\n    // Auto-reverse in/out to out/in\n    if (this.inout === Graph.IN && outlet.inout === Graph.OUT) {\n      return outlet.connect(this);\n    }\n\n    // Disallow bad combinations\n    if (this.inout !== Graph.OUT || outlet.inout !== Graph.IN) {\n      throw new Error(\"Can only connect out to in.\");\n    }\n\n    // Check for existing connection\n    if (outlet.input === this) {\n      return;\n    }\n\n    // Disconnect existing connections\n    outlet.disconnect();\n\n    // Add new connection.\n    outlet.input = this;\n    return this.output.push(outlet);\n  }\n\n  // Disconnect given outlet (or all)\n  disconnect(outlet) {\n    // Disconnect input from the other side.\n    if (this.input) {\n      this.input.disconnect(this);\n    }\n\n    if (this.output.length) {\n      if (outlet) {\n        // Remove one outgoing connection.\n        const index = this.output.indexOf(outlet);\n        if (index >= 0) {\n          this.output.splice(index, 1);\n          return (outlet.input = null);\n        }\n      } else {\n        // Remove all outgoing connections.\n        for (outlet of Array.from(this.output)) {\n          outlet.input = null;\n        }\n        return (this.output = []);\n      }\n    }\n  }\n}\nOutlet.initClass();\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Graph } from \"./graph\";\nimport { Outlet } from \"./outlet\";\n\n/*\n Node in graph.\n*/\nexport class Node {\n  static initClass() {\n    this.index = 0;\n  }\n  static id(name) {\n    return ++Node.index;\n  }\n\n  constructor(owner, outlets) {\n    this.owner = owner;\n    this.graph = null;\n    this.inputs = [];\n    this.outputs = [];\n    this.all = [];\n    this.outlets = null;\n    this.id = Node.id();\n\n    this.setOutlets(outlets);\n  }\n\n  // Retrieve input\n  getIn(name) {\n    return Array.from(this.inputs).filter((outlet) => outlet.name === name)[0];\n  }\n\n  // Retrieve output\n  getOut(name) {\n    return Array.from(this.outputs).filter((outlet) => outlet.name === name)[0];\n  }\n\n  // Retrieve by name\n  get(name) {\n    return this.getIn(name) || this.getOut(name);\n  }\n\n  // Set new outlet definition\n  setOutlets(outlets) {\n    if (outlets != null) {\n      // First init\n      let outlet;\n      if (this.outlets == null) {\n        this.outlets = {};\n        for (outlet of Array.from(outlets)) {\n          if (!(outlet instanceof Outlet)) {\n            outlet = Outlet.make(outlet);\n          }\n          this._add(outlet);\n        }\n        return;\n      }\n\n      // Return new/old outlet matching hash key\n      const hash = (\n        outlet // Match by name, direction and type.\n      ) => [outlet.name, outlet.inout, outlet.type].join(\"-\");\n\n      // Build hash of new outlets\n      const match = {};\n      for (outlet of Array.from(outlets)) {\n        match[hash(outlet)] = true;\n      }\n\n      // Remove missing outlets, record matches\n      for (let key in this.outlets) {\n        outlet = this.outlets[key];\n        key = hash(outlet);\n        if (match[key]) {\n          match[key] = outlet;\n        } else {\n          this._remove(outlet);\n        }\n      }\n\n      // Insert new outlets\n      for (outlet of Array.from(outlets)) {\n        // Find match by hash\n        const existing = match[hash(outlet)];\n        if (existing instanceof Outlet) {\n          // Update existing outlets in place to retain connections.\n          this._morph(existing, outlet);\n        } else {\n          // Spawn new outlet\n          if (!(outlet instanceof Outlet)) {\n            outlet = Outlet.make(outlet);\n          }\n          this._add(outlet);\n        }\n      }\n\n      this;\n    }\n    return this.outlets;\n  }\n\n  // Connect to the target node by matching up inputs and outputs.\n  connect(node, empty, force) {\n    let dest, dests, hint, source, type;\n    const outlets = {};\n    const hints = {};\n\n    const typeHint = (outlet) => type + \"/\" + outlet.hint;\n\n    // Hash the types/hints of available target outlets.\n    for (dest of Array.from(node.inputs)) {\n      // Only autoconnect if not already connected\n      var list;\n      if (!force && dest.input) {\n        continue;\n      }\n\n      // Match outlets by type/name hint, then type/position key\n      ({ type } = dest);\n      hint = typeHint(dest);\n\n      if (!hints[hint]) {\n        hints[hint] = dest;\n      }\n      outlets[type] = list = outlets[type] || [];\n      list.push(dest);\n    }\n\n    // Available source outlets\n    let sources = this.outputs;\n\n    // Ignore connected source if only matching empties.\n    sources = sources.filter((outlet) => !(empty && outlet.output.length));\n\n    // Match hints first\n    for (source of Array.from(sources.slice())) {\n      // Match outlets by type and name\n      ({ type } = source);\n      hint = typeHint(source);\n      dests = outlets[type];\n\n      // Connect if found\n      if ((dest = hints[hint])) {\n        source.connect(dest);\n\n        // Remove from potential set\n        delete hints[hint];\n        dests.splice(dests.indexOf(dest), 1);\n        sources.splice(sources.indexOf(source), 1);\n      }\n    }\n\n    // Match what's left\n    if (!sources.length) {\n      return this;\n    }\n    for (source of Array.from(sources.slice())) {\n      ({ type } = source);\n      dests = outlets[type];\n\n      // Match outlets by type and order\n      if (dests && dests.length) {\n        // Link up and remove from potential set\n        source.connect(dests.shift());\n      }\n    }\n\n    return this;\n  }\n\n  // Disconnect entire node\n  disconnect(node) {\n    let outlet;\n    for (outlet of Array.from(this.inputs)) {\n      outlet.disconnect();\n    }\n    for (outlet of Array.from(this.outputs)) {\n      outlet.disconnect();\n    }\n\n    return this;\n  }\n\n  // Return hash key for outlet\n  _key(outlet) {\n    return [outlet.name, outlet.inout].join(\"-\");\n  }\n\n  // Add outlet object to node\n  _add(outlet) {\n    const key = this._key(outlet);\n\n    // Sanity checks\n    if (outlet.node) {\n      throw new Error(\"Adding outlet to two nodes at once.\");\n    }\n    if (this.outlets[key]) {\n      throw new Error(`Adding two identical outlets to same node. (${key})`);\n    }\n\n    // Link back outlet\n    outlet.node = this;\n\n    // Add to name hash and inout list\n    if (outlet.inout === Graph.IN) {\n      this.inputs.push(outlet);\n    }\n    if (outlet.inout === Graph.OUT) {\n      this.outputs.push(outlet);\n    }\n    this.all.push(outlet);\n    return (this.outlets[key] = outlet);\n  }\n\n  // Morph outlet to other\n  _morph(existing, outlet) {\n    let key = this._key(outlet);\n    delete this.outlets[key];\n\n    existing.morph(outlet);\n\n    key = this._key(outlet);\n    return (this.outlets[key] = outlet);\n  }\n\n  // Remove outlet object from node.\n  _remove(outlet) {\n    const key = this._key(outlet);\n    const { inout } = outlet;\n\n    // Sanity checks\n    if (outlet.node !== this) {\n      throw new Error(\"Removing outlet from wrong node.\");\n    }\n\n    // Disconnect outlet.\n    outlet.disconnect();\n\n    // Unlink outlet.\n    outlet.node = null;\n\n    // Remove from name list and inout list.\n    delete this.outlets[key];\n    if (outlet.inout === Graph.IN) {\n      this.inputs.splice(this.inputs.indexOf(outlet), 1);\n    }\n    if (outlet.inout === Graph.OUT) {\n      this.outputs.splice(this.outputs.indexOf(outlet), 1);\n    }\n    this.all.splice(this.all.indexOf(outlet), 1);\n    return this;\n  }\n}\nNode.initClass();\n","import { Graph } from \"./graph\";\nexport const { IN, OUT } = Graph;\n\nexport * from \"./graph\";\nexport * from \"./node\";\nexport * from \"./outlet\";\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS104: Avoid inline assignments\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nexport class Snippet {\n  static initClass() {\n    this.index = 0;\n  }\n  static namespace() {\n    return `_sn_${++Snippet.index}_`;\n  }\n\n  static load(language, name, code) {\n    const program = language.parse(name, code);\n    const [sigs, compiler] = Array.from(language.compile(program));\n    return new Snippet(language, sigs, compiler, name, code);\n  }\n\n  constructor(language, _signatures, _compiler, _name, _original) {\n    this.language = language;\n    this._signatures = _signatures;\n    this._compiler = _compiler;\n    this._name = _name;\n    this._original = _original;\n    this.namespace = null;\n    this.code = null;\n\n    this.main = null;\n    this.entry = null;\n\n    this.uniforms = null;\n    this.externals = null;\n    this.symbols = null;\n    this.attributes = null;\n    this.varyings = null;\n\n    // Tidy up object for export\n    if (!this.language) {\n      delete this.language;\n    }\n    if (!this._signatures) {\n      delete this._signatures;\n    }\n    if (!this._compiler) {\n      delete this._compiler;\n    }\n    if (!this._original) {\n      delete this._original;\n    }\n\n    // Insert snippet name if not provided\n    if (!this._name) {\n      this._name =\n        this._signatures != null ? this._signatures.main.name : undefined;\n    }\n  }\n\n  clone() {\n    return new Snippet(\n      this.language,\n      this._signatures,\n      this._compiler,\n      this._name,\n      this._original\n    );\n  }\n\n  bind(config, uniforms, namespace, defines) {\n    // Alt syntax (namespace, uniforms, defines)\n    let def, left;\n    let v;\n    if (uniforms === \"\" + uniforms) {\n      [namespace, uniforms, defines] = Array.from([\n        uniforms,\n        namespace != null ? namespace : {},\n        defines != null ? defines : {},\n      ]);\n      // Alt syntax (uniforms, defines)\n    } else if (namespace !== \"\" + namespace) {\n      [defines, namespace] = Array.from([\n        namespace != null ? namespace : {},\n        undefined,\n      ]);\n    }\n\n    // Prepare data structure\n    this.main = this._signatures.main;\n    this.namespace =\n      (left = namespace != null ? namespace : this.namespace) != null\n        ? left\n        : Snippet.namespace();\n    this.entry = this.namespace + this.main.name;\n\n    this.uniforms = {};\n    this.varyings = {};\n    this.attributes = {};\n    this.externals = {};\n    this.symbols = [];\n    const exist = {};\n    const exceptions = {};\n\n    // Handle globals and locals for prefixing\n    const global = function (name) {\n      exceptions[name] = true;\n      return name;\n    };\n    const local = (name) => {\n      return this.namespace + name;\n    };\n\n    // Apply config\n    if (config.globals) {\n      for (let key of Array.from(config.globals)) {\n        global(key);\n      }\n    }\n    const _u = config.globalUniforms ? global : local;\n    const _v = config.globalVaryings ? global : local;\n    const _a = config.globalAttributes ? global : local;\n    const _e = local;\n\n    // Build finalized properties\n    const x = (def) => {\n      return (exist[def.name] = true);\n    };\n    const u = (def, name) => {\n      return (this.uniforms[_u(name != null ? name : def.name)] = def);\n    };\n    v = (def) => {\n      return (this.varyings[_v(def.name)] = def);\n    };\n    const a = (def) => {\n      return (this.attributes[_a(def.name)] = def);\n    };\n    const e = (def) => {\n      const name = _e(def.name);\n      this.externals[name] = def;\n      return this.symbols.push(name);\n    };\n\n    const redef = (def) => ({\n      type: def.type,\n      name: def.name,\n      value: def.value,\n    });\n\n    for (def of Array.from(this._signatures.uniform)) {\n      x(def);\n    }\n    for (def of Array.from(this._signatures.uniform)) {\n      u(redef(def));\n    }\n    for (def of Array.from(this._signatures.varying)) {\n      v(redef(def));\n    }\n    for (def of Array.from(this._signatures.external)) {\n      e(def);\n    }\n    for (def of Array.from(this._signatures.attribute)) {\n      a(redef(def));\n    }\n    for (let name in uniforms) {\n      def = uniforms[name];\n      if (exist[name]) {\n        u(def, name);\n      }\n    }\n\n    this.body = this.code = this._compiler(this.namespace, exceptions, defines);\n\n    // Adds defs to original snippet for inspection\n    if (defines) {\n      const defs = (() => {\n        const result = [];\n        for (let k in defines) {\n          v = defines[k];\n          result.push(`#define ${k} ${v}`);\n        }\n        return result;\n      })().join(\"\\n\");\n      if (defs.length) {\n        this._original = [\n          defs,\n          \"//----------------------------------------\",\n          this._original,\n        ].join(\"\\n\");\n      }\n    }\n\n    return null;\n  }\n}\nSnippet.initClass();\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport * as Graph from \"../graph\";\nimport * as Priority from \"./priority\";\n\n/*\n  Program assembler\n\n  Builds composite program that can act as new module/snippet\n  Unconnected input/outputs and undefined callbacks are exposed in the new global/main scope\n  If there is only one call with an identical call signature, a #define is output instead.\n*/\nexport const assemble = function (language, namespace, calls, requires) {\n  const generate = language;\n\n  const externals = {};\n  const symbols = [];\n  const uniforms = {};\n  const varyings = {};\n  const attributes = {};\n  const library = {};\n\n  const process = function () {\n    let body;\n    let ns;\n    for (ns in requires) {\n      const r = requires[ns];\n      required(r.node, r.module);\n    }\n\n    [body, calls] = Array.from(handle(calls));\n    if (namespace != null) {\n      body.entry = namespace;\n    }\n    const main = generate.build(body, calls);\n\n    const sorted = (() => {\n      const result = [];\n      for (ns in library) {\n        const lib = library[ns];\n        result.push(lib);\n      }\n      return result;\n    })().sort((a, b) => Priority.compare(a.priority, b.priority));\n    const includes = sorted.map((x) => x.code);\n    includes.push(main.code);\n    const code = generate.lines(includes);\n\n    // Build new virtual snippet\n    return {\n      namespace: main.name,\n      library, // Included library functions\n      body: main.code, // Snippet body\n      code, // Complete snippet (tests/debug)\n      main, // Function signature\n      entry: main.name, // Entry point name\n      symbols,\n      externals,\n      uniforms,\n      varyings,\n      attributes,\n    };\n  };\n\n  // Sort and process calls\n  var handle = (calls) => {\n    let c;\n    calls = (() => {\n      const result = [];\n      for (let ns in calls) {\n        c = calls[ns];\n        result.push(c);\n      }\n      return result;\n    })();\n    calls.sort((a, b) => b.priority - a.priority);\n\n    // Call module in DAG chain\n    const call = (node, module, priority) => {\n      include(node, module, priority);\n      const { main } = module;\n      const { entry } = module;\n\n      const _lookup = (name) => lookup(node, name);\n      const _dangling = (name) => isDangling(node, name);\n      return generate.call(_lookup, _dangling, entry, main.signature, body);\n    };\n\n    var body = generate.body();\n    for (c of Array.from(calls)) {\n      call(c.node, c.module, c.priority);\n    }\n\n    return [body, calls];\n  };\n\n  // Adopt given code as a library at given priority\n  const adopt = function (namespace, code, priority) {\n    const record = library[namespace];\n    if (record != null) {\n      return (record.priority = Priority.max(record.priority, priority));\n    } else {\n      return (library[namespace] = { code, priority });\n    }\n  };\n\n  // Include snippet for a call\n  var include = function (node, module, priority) {\n    let def, key;\n    priority = Priority.make(priority);\n\n    // Adopt snippet's libraries\n    for (let ns in module.library) {\n      const lib = module.library[ns];\n      adopt(ns, lib.code, Priority.nest(priority, lib.priority));\n    }\n\n    // Adopt snippet body as library\n    adopt(module.namespace, module.body, priority);\n\n    // Adopt GL vars\n    for (key in module.uniforms) {\n      def = module.uniforms[key];\n      uniforms[key] = def;\n    }\n    for (key in module.varyings) {\n      def = module.varyings[key];\n      varyings[key] = def;\n    }\n    for (key in module.attributes) {\n      def = module.attributes[key];\n      attributes[key] = def;\n    }\n\n    return required(node, module);\n  };\n\n  var required = (\n    node,\n    module // Adopt external symbols\n  ) =>\n    (() => {\n      const result = [];\n      for (let key of Array.from(module.symbols)) {\n        const ext = module.externals[key];\n        if (isDangling(node, ext.name)) {\n          const copy = {};\n          for (let k in ext) {\n            const v = ext[k];\n            copy[k] = v;\n          }\n          copy.name = lookup(node, ext.name);\n          externals[key] = copy;\n          result.push(symbols.push(key));\n        } else {\n          result.push(undefined);\n        }\n      }\n      return result;\n    })();\n\n  // Check for dangling input/output\n  var isDangling = function (node, name) {\n    const outlet = node.get(name);\n\n    if (outlet.inout === Graph.IN) {\n      return outlet.input === null;\n    } else if (outlet.inout === Graph.OUT) {\n      return outlet.output.length === 0;\n    }\n  };\n\n  // Look up unique name for outlet\n  var lookup = function (node, name) {\n    // Traverse graph edge\n    let outlet = node.get(name);\n    if (!outlet) {\n      return null;\n    }\n\n    if (outlet.input) {\n      outlet = outlet.input;\n    }\n    ({ name } = outlet);\n\n    return outlet.id;\n  };\n\n  return process();\n};\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Snippet } from \"./snippet\";\nimport { assemble } from \"./assemble\";\n\n/*\n  Program assembly model\n\n  Snippets are added to its queue, registering calls and code includes.\n  Calls are de-duped and scheduled at the earliest point required for correct data flow.\n\n  When assemble() is called, it builds a main() function to\n  execute all calls in final order.\n\n  The result is a new instance of Snippet that acts as if it\n  was parsed from the combined source of the component\n  nodes.\n*/\nexport class Program {\n  static initClass() {\n    this.index = 0;\n  }\n  static entry() {\n    return `_pg_${++Program.index}_`;\n  }\n\n  // Program starts out empty, ready to compile starting from a particular block\n  constructor(language, namespace, graph) {\n    this.language = language;\n    this.namespace = namespace;\n    this.graph = graph;\n    this.calls = {};\n    this.requires = {};\n  }\n\n  // Call a given module at certain priority\n  call(node, module, priority) {\n    let exists;\n    const ns = module.namespace;\n\n    // Merge all calls down into one with the right priority\n    if ((exists = this.calls[ns])) {\n      exists.priority = Math.max(exists.priority, priority);\n    } else {\n      this.calls[ns] = { node, module, priority };\n    }\n\n    return this;\n  }\n\n  // Require a given (callback) module's externals\n  require(node, module) {\n    const ns = module.namespace;\n    return (this.requires[ns] = { node, module });\n  }\n\n  // Compile queued ops into result\n  assemble() {\n    const data = assemble(\n      this.language,\n      this.namespace != null ? this.namespace : Program.entry,\n      this.calls,\n      this.requires\n    );\n    const snippet = new Snippet();\n    for (let key in data) {\n      snippet[key] = data[key];\n    }\n    snippet.graph = this.graph;\n    return snippet;\n  }\n}\nProgram.initClass();\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport * as Graph from \"../graph\";\nimport * as Priority from \"./priority\";\n\n/*\n Callback linker\n\n Imports given modules and generates linkages for registered callbacks.\n\n Builds composite program with single module as exported entry point\n*/\n\nexport const link = function (language, links, modules, exported) {\n  const generate = language;\n  let includes = [];\n\n  const symbols = [];\n  const externals = {};\n  const uniforms = {};\n  const attributes = {};\n  const varyings = {};\n  const library = {};\n\n  const process = function () {\n    const exports = generate.links(links);\n\n    const header = [];\n    if (exports.defs != null) {\n      header.push(exports.defs);\n    }\n    if (exports.bodies != null) {\n      header.push(exports.bodies);\n    }\n\n    for (let m of Array.from(modules)) {\n      include(m.node, m.module, m.priority);\n    }\n    const sorted = (() => {\n      const result = [];\n      for (let ns in library) {\n        const lib = library[ns];\n        result.push(lib);\n      }\n      return result;\n    })().sort((a, b) => Priority.compare(a.priority, b.priority));\n    includes = sorted.map((x) => x.code);\n\n    let code = generate.lines(includes);\n    code = generate.defuse(code);\n    if (header.length) {\n      code = [generate.lines(header), code].join(\"\\n\");\n    }\n    code = generate.hoist(code);\n    code = generate.dedupe(code);\n\n    // Export module's externals\n    const e = exported;\n    return {\n      namespace: e.main.name,\n      code, // Complete snippet (tests/debug)\n      main: e.main, // Function signature\n      entry: e.main.name, // Entry point name\n      externals,\n      uniforms,\n      attributes,\n      varyings,\n    };\n  };\n\n  // Adopt given code as a library at given priority\n  const adopt = function (namespace, code, priority) {\n    const record = library[namespace];\n    if (record != null) {\n      return (record.priority = Priority.max(record.priority, priority));\n    } else {\n      return (library[namespace] = { code, priority });\n    }\n  };\n\n  // Include piece of code\n  var include = function (node, module, priority) {\n    let def, key;\n    priority = Priority.make(priority);\n\n    // Adopt snippet's libraries\n    for (let ns in module.library) {\n      const lib = module.library[ns];\n      adopt(ns, lib.code, Priority.nest(priority, lib.priority));\n    }\n\n    // Adopt snippet body as library\n    adopt(module.namespace, module.body, priority);\n\n    // Adopt externals\n    for (key in module.uniforms) {\n      def = module.uniforms[key];\n      uniforms[key] = def;\n    }\n    for (key in module.varyings) {\n      def = module.varyings[key];\n      varyings[key] = def;\n    }\n    for (key in module.attributes) {\n      def = module.attributes[key];\n      attributes[key] = def;\n    }\n\n    return (() => {\n      const result = [];\n      for (key of Array.from(module.symbols)) {\n        const ext = module.externals[key];\n        if (isDangling(node, ext.name)) {\n          externals[key] = ext;\n          result.push(symbols.push(key));\n        } else {\n          result.push(undefined);\n        }\n      }\n      return result;\n    })();\n  };\n\n  // Check for dangling input/output\n  var isDangling = function (node, name) {\n    const outlet = node.get(name);\n\n    if (!outlet) {\n      const module =\n        (node.owner.snippet != null ? node.owner.snippet._name : undefined) !=\n        null\n          ? node.owner.snippet != null\n            ? node.owner.snippet._name\n            : undefined\n          : node.owner.namespace;\n      throw new Error(\n        `Unable to link program. Unlinked callback \\`${name}\\` on \\`${module}\\``\n      );\n    }\n\n    if (outlet.inout === Graph.IN) {\n      return outlet.input === null;\n    } else if (outlet.inout === Graph.OUT) {\n      return outlet.output.length === 0;\n    }\n  };\n\n  return process();\n};\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Snippet } from \"./snippet\";\nimport { link } from \"./link\";\n\nconst debug = false;\n\n/*\n  Program linkage layout\n\n  Entry points are added to its dependency graph\n  Callbacks are linked either with a go-between function\n  or a #define if the signatures are identical.\n*/\nexport class Layout {\n  constructor(language, graph) {\n    this.language = language;\n    this.graph = graph;\n    this.links = [];\n    this.includes = [];\n    this.modules = {};\n    this.visits = {};\n  }\n\n  // Link up a given named external to this module's entry point\n  callback(node, module, priority, name, external) {\n    return this.links.push({ node, module, priority, name, external });\n  }\n\n  // Include this module of code\n  include(node, module, priority) {\n    let m;\n    if ((m = this.modules[module.namespace]) != null) {\n      return (m.priority = Math.max(priority, m.priority));\n    } else {\n      this.modules[module.namespace] = true;\n      return this.includes.push({ node, module, priority });\n    }\n  }\n\n  // Visit each namespace at most once to avoid infinite recursion\n  visit(namespace) {\n    debug && console.log(\"Visit\", namespace, !this.visits[namespace]);\n    if (this.visits[namespace]) {\n      return false;\n    }\n    return (this.visits[namespace] = true);\n  }\n\n  // Compile queued ops into result\n  link(module) {\n    const data = link(this.language, this.links, this.includes, module);\n    const snippet = new Snippet();\n    for (let key in data) {\n      snippet[key] = data[key];\n    }\n    snippet.graph = this.graph;\n    return snippet;\n  }\n}\n","import { Snippet } from \"./snippet\";\n\nexport const { load } = Snippet;\n\nexport * from \"./snippet\";\nexport * from \"./program\";\nexport * from \"./layout\";\nexport * from \"./assemble\";\nexport * from \"./link\";\nexport * from \"./priority\";\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS103: Rewrite code to no longer use __guard__, or convert again using --optional-chaining\n * DS104: Avoid inline assignments\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\nimport * as Graph from \"../graph\";\nimport { Program, Layout } from \"../linker\";\n\nlet debug = false;\n\nexport class Block {\n  static previous(outlet) {\n    return outlet.input != null ? outlet.input.node.owner : undefined;\n  }\n\n  constructor(delay) {\n    // Subclasses can pass `delay` to allow them to initialize before they call\n    // `@construct`.\n    if (delay == null) {\n      delay = false;\n    }\n    if (!delay) {\n      this.construct();\n    }\n  }\n\n  construct() {\n    let left;\n    if (this.namespace == null) {\n      this.namespace = Program.entry();\n    }\n    return (this.node = new Graph.Node(\n      this,\n      (left =\n        typeof this.makeOutlets === \"function\"\n          ? this.makeOutlets()\n          : undefined) != null\n        ? left\n        : {}\n    ));\n  }\n\n  refresh() {\n    let left;\n    return this.node.setOutlets(\n      (left =\n        typeof this.makeOutlets === \"function\"\n          ? this.makeOutlets()\n          : undefined) != null\n        ? left\n        : {}\n    );\n  }\n\n  clone() {\n    return new Block();\n  }\n\n  // Compile a new program starting from this block\n  compile(language, namespace) {\n    const program = new Program(\n      language,\n      namespace != null ? namespace : Program.entry(),\n      this.node.graph\n    );\n    this.call(program, 0);\n    return program.assemble();\n  }\n\n  // Link up programs into a layout, starting from this block\n  link(language, namespace) {\n    const module = this.compile(language, namespace);\n\n    const layout = new Layout(language, this.node.graph);\n    this._include(module, layout, 0);\n    this.export(layout, 0);\n    return layout.link(module);\n  }\n\n  // Subclassed methods\n  call(_program, _depth) {}\n  callback(_layout, _depth, _name, _external, _outlet) {}\n  export(_layout, _depth) {}\n\n  // Info string for debugging\n  _info(suffix) {\n    let string =\n      (this.node.owner.snippet != null\n        ? this.node.owner.snippet._name\n        : undefined) != null\n        ? this.node.owner.snippet != null\n          ? this.node.owner.snippet._name\n          : undefined\n        : this.node.owner.namespace;\n    if (suffix != null) {\n      return (string += \".\" + suffix);\n    }\n  }\n\n  // Create an outlet for a signature definition\n  _outlet(def, props) {\n    const outlet = Graph.Outlet.make(def, props);\n    outlet.meta.def = def;\n    return outlet;\n  }\n\n  // Make a call to this module in the given program\n  _call(module, program, depth) {\n    return program.call(this.node, module, depth);\n  }\n\n  // Require this module's dependencies in the given program\n  _require(module, program) {\n    return program.require(this.node, module);\n  }\n\n  // Make a call to all connected inputs\n  _inputs(module, program, depth) {\n    return (() => {\n      const result = [];\n      for (let arg of Array.from(module.main.signature)) {\n        const outlet = this.node.get(arg.name);\n        result.push(\n          __guard__(Block.previous(outlet), (x) => x.call(program, depth + 1))\n        );\n      }\n      return result;\n    })();\n  }\n\n  // Insert callback to this module in the given layout\n  _callback(module, layout, depth, name, external, outlet) {\n    return layout.callback(this.node, module, depth, name, external, outlet);\n  }\n\n  // Include this module in the given layout\n  _include(module, layout, depth) {\n    return layout.include(this.node, module, depth);\n  }\n\n  // Link this module's connected callbacks\n  _link(module, layout, depth) {\n    debug && console.log(\"block::_link\", this.toString(), module.namespace);\n    return (() => {\n      const result = [];\n      for (let key of Array.from(module.symbols)) {\n        const ext = module.externals[key];\n        let outlet = this.node.get(ext.name);\n        if (!outlet) {\n          throw new OutletError(\n            `External not found on ${this._info(ext.name)}`\n          );\n        }\n\n        if (outlet.meta.child != null) {\n          continue;\n        }\n\n        let parent = outlet;\n        let block;\n        while (!block && parent) {\n          [parent, outlet] = Array.from([outlet.meta.parent, parent]);\n        }\n\n        block = Block.previous(outlet);\n        if (!block) {\n          throw new OutletError(\n            `Missing connection on ${this._info(ext.name)}`\n          );\n        }\n\n        debug && console.log(\"callback -> \", this.toString(), ext.name, outlet);\n        block.callback(layout, depth + 1, key, ext, outlet.input);\n        result.push(\n          block != null ? block.export(layout, depth + 1) : undefined\n        );\n      }\n      return result;\n    })();\n  }\n\n  // Trace backwards to discover callbacks further up\n  _trace(module, layout, depth) {\n    debug && console.log(\"block::_trace\", this.toString(), module.namespace);\n    return (() => {\n      const result = [];\n      for (let arg of Array.from(module.main.signature)) {\n        const outlet = this.node.get(arg.name);\n        result.push(\n          __guard__(Block.previous(outlet), (x) => x.export(layout, depth + 1))\n        );\n      }\n      return result;\n    })();\n  }\n}\n\nvar OutletError = function (message) {\n  const e = new Error(message);\n  e.name = \"OutletError\";\n  return e;\n};\n\nOutletError.prototype = new Error();\n\nfunction __guard__(value, transform) {\n  return typeof value !== \"undefined\" && value !== null\n    ? transform(value)\n    : undefined;\n}\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Block } from \"./block\";\n\nexport class Call extends Block {\n  constructor(snippet) {\n    super(true);\n\n    this.snippet = snippet;\n    this.namespace = snippet.namespace;\n    this.construct();\n  }\n\n  clone() {\n    return new Call(this.snippet);\n  }\n\n  makeOutlets() {\n    const main = this.snippet.main.signature;\n    const { externals } = this.snippet;\n    const { symbols } = this.snippet;\n\n    const params = Array.from(main).map((outlet) =>\n      this._outlet(outlet, { callback: false })\n    );\n    const callbacks = Array.from(symbols).map((key) =>\n      this._outlet(externals[key], { callback: true })\n    );\n\n    return params.concat(callbacks);\n  }\n\n  call(program, depth) {\n    this._call(this.snippet, program, depth);\n    return this._inputs(this.snippet, program, depth);\n  }\n\n  export(layout, depth) {\n    if (!layout.visit(this.namespace, depth)) {\n      return;\n    }\n\n    this._link(this.snippet, layout, depth);\n    return this._trace(this.snippet, layout, depth);\n  }\n}\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Graph } from \"../graph\";\nimport { Block } from \"./block\";\n\n/*\n  Re-use a subgraph as a callback\n*/\nexport class Callback extends Block {\n  constructor(graph) {\n    super(true);\n    this.graph = graph;\n    this.construct();\n  }\n\n  refresh() {\n    super.refresh();\n    return delete this.subroutine;\n  }\n\n  clone() {\n    return new Callback(this.graph);\n  }\n\n  makeOutlets() {\n    let outlet;\n    this.make();\n\n    const outlets = [];\n    let ins = [];\n    let outs = [];\n\n    // Pass-through existing callbacks\n    // Collect open inputs/outputs\n    const handle = (outlet, list) => {\n      if (outlet.meta.callback) {\n        if (outlet.inout === Graph.IN) {\n          // Dupe outlet and create two-way link between cloned outlets\n          const dupe = outlet.dupe();\n          if (dupe.meta.child == null) {\n            dupe.meta.child = outlet;\n          }\n          outlet.meta.parent = dupe;\n\n          return outlets.push(dupe);\n        }\n      } else {\n        return list.push(outlet.type);\n      }\n    };\n\n    for (outlet of Array.from(this.graph.inputs())) {\n      handle(outlet, ins);\n    }\n    for (outlet of Array.from(this.graph.outputs())) {\n      handle(outlet, outs);\n    }\n\n    // Merge inputs/outputs into new callback signature\n    ins = ins.join(\",\");\n    outs = outs.join(\",\");\n    const type = `(${ins})(${outs})`;\n\n    outlets.push({\n      name: \"callback\",\n      type,\n      inout: Graph.OUT,\n      meta: {\n        callback: true,\n        def: this.subroutine.main,\n      },\n    });\n\n    return outlets;\n  }\n\n  make() {\n    return (this.subroutine = this.graph.compile(this.namespace));\n  }\n\n  export(layout, depth) {\n    if (!layout.visit(this.namespace, depth)) {\n      return;\n    }\n\n    this._link(this.subroutine, layout, depth);\n    return this.graph.export(layout, depth);\n  }\n\n  call(program, depth) {\n    return this._require(this.subroutine, program, depth);\n  }\n\n  callback(layout, depth, name, external, outlet) {\n    this._include(this.subroutine, layout, depth);\n    return this._callback(\n      this.subroutine,\n      layout,\n      depth,\n      name,\n      external,\n      outlet\n    );\n  }\n}\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Graph } from \"../graph\";\nimport { Block } from \"./block\";\n\n/*\n  Isolate a subgraph as a single node\n*/\nexport class Isolate extends Block {\n  constructor(graph) {\n    super(true);\n    this.graph = graph;\n    this.construct();\n  }\n\n  refresh() {\n    super.refresh();\n    return delete this.subroutine;\n  }\n\n  clone() {\n    return new Isolate(this.graph);\n  }\n\n  makeOutlets() {\n    this.make();\n\n    const outlets = [];\n\n    const seen = {};\n    const done = {};\n    for (let set of [\"inputs\", \"outputs\"]) {\n      for (let outlet of Array.from(this.graph[set]())) {\n        // Preserve name of 'return' and 'callback' outlets\n        let name = undefined;\n        if (\n          [\"return\", \"callback\"].includes(outlet.hint) &&\n          outlet.inout === Graph.OUT\n        ) {\n          name = outlet.hint;\n        }\n\n        // Unless it already exists\n        if (seen[name] != null) {\n          name = undefined;\n        }\n\n        // Dupe outlet and remember link to original\n        const dupe = outlet.dupe(name);\n        if (dupe.meta.child == null) {\n          dupe.meta.child = outlet;\n        }\n        outlet.meta.parent = dupe;\n        if (name != null) {\n          seen[name] = true;\n        }\n        done[outlet.name] = dupe;\n\n        outlets.push(dupe);\n      }\n    }\n\n    return outlets;\n  }\n\n  make() {\n    return (this.subroutine = this.graph.compile(this.namespace));\n  }\n\n  call(program, depth) {\n    this._call(this.subroutine, program, depth);\n    return this._inputs(this.subroutine, program, depth);\n  }\n\n  export(layout, depth) {\n    if (!layout.visit(this.namespace, depth)) {\n      return;\n    }\n\n    // Link up with normal inputs\n    this._link(this.subroutine, layout, depth);\n    this._trace(this.subroutine, layout, depth);\n\n    // Export callbacks needed to call the subroutine\n    return this.graph.export(layout, depth);\n  }\n\n  callback(layout, depth, name, external, outlet) {\n    outlet = outlet.meta.child;\n    return outlet.node.owner.callback(layout, depth, name, external, outlet);\n  }\n}\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Block } from \"./block\";\n\n/*\n  Join multiple disconnected nodes\n*/\nexport class Join extends Block {\n  constructor(nodes) {\n    super(true);\n    this.nodes = nodes;\n    this.construct();\n  }\n\n  clone() {\n    return new Join(this.nodes);\n  }\n\n  makeOutlets() {\n    return [];\n  }\n\n  call(program, depth) {\n    return (() => {\n      const result = [];\n      for (let node of Array.from(this.nodes)) {\n        const block = node.owner;\n        result.push(block.call(program, depth));\n      }\n      return result;\n    })();\n  }\n\n  export(layout, depth) {\n    return (() => {\n      const result = [];\n      for (let node of Array.from(this.nodes)) {\n        const block = node.owner;\n        result.push(block.export(layout, depth));\n      }\n      return result;\n    })();\n  }\n}\n","export * from \"./block\";\nexport * from \"./call\";\nexport * from \"./callback\";\nexport * from \"./isolate\";\nexport * from \"./join\";\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// Dump graph for debug/visualization purposes\nimport * as Block from \"../block\";\n\nconst isCallback = (outlet) => outlet.type[0] === \"(\";\n\nexport var serialize = function (graph) {\n  const nodes = [];\n  const links = [];\n\n  for (let node of Array.from(graph.nodes)) {\n    var outlet;\n    const record = {\n      // Data\n      id: node.id,\n      name: null,\n      type: null,\n      depth: null,\n      graph: null,\n      inputs: [],\n      outputs: [],\n    };\n\n    nodes.push(record);\n\n    const { inputs } = record;\n    const { outputs } = record;\n\n    const block = node.owner;\n\n    if (block instanceof Block.Call) {\n      record.name = block.snippet._name;\n      record.type = \"call\";\n      record.code = block.snippet._original;\n    } else if (block instanceof Block.Callback) {\n      record.name = \"Callback\";\n      record.type = \"callback\";\n      record.graph = serialize(block.graph);\n    } else if (block instanceof Block.Isolate) {\n      record.name = \"Isolate\";\n      record.type = \"isolate\";\n      record.graph = serialize(block.graph);\n    } else if (block instanceof Block.Join) {\n      record.name = \"Join\";\n      record.type = \"join\";\n    } else if (block != null) {\n      if (record.name == null) {\n        record.name = block.name != null ? block.name : block.type;\n      }\n      if (record.type == null) {\n        record.type = block.type;\n      }\n      if (record.code == null) {\n        record.code = block.code;\n      }\n      if (block.graph != null) {\n        record.graph = serialize(block.graph);\n      }\n    }\n\n    const format = function (type) {\n      type = type.replace(\")(\", \")→(\");\n      return (type = type.replace(\"()\", \"\"));\n    };\n\n    for (outlet of Array.from(node.inputs)) {\n      inputs.push({\n        id: outlet.id,\n        name: outlet.name,\n        type: format(outlet.type),\n        open: outlet.input == null,\n      });\n    }\n\n    for (outlet of Array.from(node.outputs)) {\n      outputs.push({\n        id: outlet.id,\n        name: outlet.name,\n        type: format(outlet.type),\n        open: !outlet.output.length,\n      });\n\n      for (let other of Array.from(outlet.output)) {\n        links.push({\n          from: node.id,\n          out: outlet.id,\n          to: other.node.id,\n          in: other.id,\n          type: format(outlet.type),\n        });\n      }\n    }\n  }\n\n  return { nodes, links };\n};\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// Hash string into a 32-bit key (murmurhash3)\nconst c1 = 0xcc9e2d51;\nconst c2 = 0x1b873593;\nconst c3 = 0xe6546b64;\nconst c4 = 0x85ebca6b;\nconst c5 = 0xc2b2ae35;\n\n// Fix imul in old/broken browsers\nlet imul = function (a, b) {\n  const ah = (a >>> 16) & 0xffff;\n  const al = a & 0xffff;\n  const bh = (b >>> 16) & 0xffff;\n  const bl = b & 0xffff;\n  return (al * bl + (((ah * bl + al * bh) << 16) >>> 0)) | 0;\n};\n\nif (Math.imul != null) {\n  const test = Math.imul(0xffffffff, 5);\n  if (test === -5) {\n    ({ imul } = Math);\n  }\n}\n\nexport const hash = function (string) {\n  let h;\n  const n = string.length;\n  let m = Math.floor(n / 2);\n  let j = (h = 0);\n\n  const next = () => string.charCodeAt(j++);\n  const iterate = function (a, b) {\n    let k = a | (b << 16); // two utf-16 words\n    k ^= k << 9; // whitening for ascii-only strings\n\n    k = imul(k, c1);\n    k = (k << 15) | (k >>> 17);\n    k = imul(k, c2);\n\n    h ^= k;\n\n    h = (h << 13) | (h >>> 19);\n    h = imul(h, 5);\n    return (h = (h + c3) | 0);\n  };\n\n  while (m--) {\n    iterate(next(), next());\n  }\n  if (n & 1) {\n    iterate(next(), 0);\n  }\n\n  h ^= n;\n  h ^= h >>> 16;\n  h = imul(h, c4);\n  h ^= h >>> 13;\n  h = imul(h, c5);\n\n  return (h ^= h >>> 16);\n};\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { hash } from \"../factory/hash\";\n\nconst trim = (string) => (\"\" + string).replace(/^\\s+|\\s+$/g, \"\");\n\nconst cssColor = (r, g, b, alpha) =>\n  \"rgba(\" + [r, g, b, alpha].join(\", \") + \")\";\n\nconst hashColor = function (string, alpha) {\n  if (alpha == null) {\n    alpha = 1;\n  }\n  const color = hash(string) ^ 0x123456;\n\n  let r = color & 0xff;\n  let g = (color >>> 8) & 0xff;\n  let b = (color >>> 16) & 0xff;\n\n  const max = Math.max(r, g, b);\n  const norm = 140 / max;\n  const min = Math.round(max / 3);\n\n  r = Math.min(255, Math.round(norm * Math.max(r, min)));\n  g = Math.min(255, Math.round(norm * Math.max(g, min)));\n  b = Math.min(255, Math.round(norm * Math.max(b, min)));\n\n  return cssColor(r, g, b, alpha);\n};\n\nconst escapeText = function (string) {\n  string = string != null ? string : \"\";\n  return string\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/'/g, \"&#39;\")\n    .replace(/\"/g, \"&quot;\");\n};\n\nexport const process = function (data) {\n  const links = [];\n  const el = _markup(data, links);\n  el.update = () => connect(el, links);\n  _activate(el);\n  return el;\n};\n\nvar _activate = function (el) {\n  const codes = el.querySelectorAll(\".shadergraph-code\");\n  return Array.from(codes).map((code) =>\n    (function () {\n      const popup = code;\n      popup.parentNode.classList.add(\"shadergraph-has-code\");\n      return popup.parentNode.addEventListener(\n        \"click\",\n        (event) =>\n          (popup.style.display = {\n            block: \"none\",\n            none: \"block\",\n          }[popup.style.display || \"none\"])\n      );\n    })()\n  );\n};\n\nconst _order = function (data) {\n  let link, node;\n  const nodeMap = {};\n  const linkMap = {};\n  for (node of Array.from(data.nodes)) {\n    nodeMap[node.id] = node;\n  }\n\n  for (link of Array.from(data.links)) {\n    if (linkMap[link.from] == null) {\n      linkMap[link.from] = [];\n    }\n    linkMap[link.from].push(link);\n  }\n\n  var recurse = function (node, depth) {\n    let next;\n    if (depth == null) {\n      depth = 0;\n    }\n    node.depth = Math.max(node.depth != null ? node.depth : 0, depth);\n    if ((next = linkMap[node.id])) {\n      for (link of Array.from(next)) {\n        recurse(nodeMap[link.to], depth + 1);\n      }\n    }\n    return null;\n  };\n\n  for (node of Array.from(data.nodes)) {\n    if (node.depth == null) {\n      recurse(node);\n    }\n  }\n\n  return null;\n};\n\nvar _markup = function (data, links) {\n  let column;\n  _order(data);\n\n  const wrapper = document.createElement(\"div\");\n  wrapper.classList.add(\"shadergraph-graph\");\n\n  const columns = [];\n  const outlets = {};\n\n  for (let node of Array.from(data.nodes)) {\n    var outlet;\n    var block = document.createElement(\"div\");\n    block.classList.add(\"shadergraph-node\");\n    block.classList.add(`shadergraph-node-${node.type}`);\n\n    block.innerHTML = `\\\n<div class=\"shadergraph-header\">${escapeText(node.name)}</div>\\\n`;\n\n    const addOutlet = function (outlet, inout) {\n      const color = hashColor(outlet.type);\n\n      const div = document.createElement(\"div\");\n      div.classList.add(\"shadergraph-outlet\");\n      div.classList.add(`shadergraph-outlet-${inout}`);\n      div.innerHTML = `\\\n<div class=\"shadergraph-point\" style=\"background: ${color}\"></div>\n<div class=\"shadergraph-type\" style=\"color: ${color}\">${escapeText(\n        outlet.type\n      )}</div>\n<div class=\"shadergraph-name\">${escapeText(outlet.name)}</div>\\\n`;\n      block.appendChild(div);\n\n      return (outlets[outlet.id] = div.querySelector(\".shadergraph-point\"));\n    };\n\n    for (outlet of Array.from(node.inputs)) {\n      addOutlet(outlet, \"in\");\n    }\n    for (outlet of Array.from(node.outputs)) {\n      addOutlet(outlet, \"out\");\n    }\n\n    if (node.graph != null) {\n      block.appendChild(_markup(node.graph, links));\n    } else {\n      const clear = document.createElement(\"div\");\n      clear.classList.add(\"shadergraph-clear\");\n      block.appendChild(clear);\n    }\n\n    if (node.code != null) {\n      const div = document.createElement(\"div\");\n      div.classList.add(\"shadergraph-code\");\n      div.innerHTML = escapeText(trim(node.code));\n      block.appendChild(div);\n    }\n\n    column = columns[node.depth];\n    if (column == null) {\n      column = document.createElement(\"div\");\n      column.classList.add(\"shadergraph-column\");\n      columns[node.depth] = column;\n    }\n    column.appendChild(block);\n  }\n\n  for (column of Array.from(columns)) {\n    if (column != null) {\n      wrapper.appendChild(column);\n    }\n  }\n\n  for (let link of Array.from(data.links)) {\n    const color = hashColor(link.type);\n\n    links.push({\n      color,\n      out: outlets[link.out],\n      in: outlets[link.in],\n    });\n  }\n\n  return wrapper;\n};\n\nconst sqr = (x) => x * x;\n\nconst path = function (x1, y1, x2, y2) {\n  let h;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const d = Math.sqrt(sqr(dx) + sqr(dy));\n\n  const vert = Math.abs(dy) > Math.abs(dx);\n  if (vert) {\n    const mx = (x1 + x2) / 2;\n    const my = (y1 + y2) / 2;\n\n    const f = dy > 0 ? 0.3 : -0.3;\n    h = Math.min(Math.abs(dx) / 2, 20 + d / 8);\n\n    return [\n      \"M\",\n      x1,\n      y1,\n      \"C\",\n      x1 + h,\n      y1 + \",\",\n      mx,\n      my - d * f,\n      mx,\n      my,\n      \"C\",\n      mx,\n      my + d * f,\n      x2 - h,\n      y2 + \",\",\n      x2,\n      y2,\n    ].join(\" \");\n  } else {\n    h = Math.min(Math.abs(dx) / 2.5, 20 + d / 4);\n\n    return [\"M\", x1, y1, \"C\", x1 + h, y1 + \",\", x2 - h, y2 + \",\", x2, y2].join(\n      \" \"\n    );\n  }\n};\n\nconst makeSVG = function (tag) {\n  if (tag == null) {\n    tag = \"svg\";\n  }\n  return document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n};\n\nvar connect = function (element, links) {\n  let link;\n  if (element.parentNode == null) {\n    return;\n  }\n\n  const ref = element.getBoundingClientRect();\n\n  for (link of Array.from(links)) {\n    const a = link.out.getBoundingClientRect();\n    const b = link.in.getBoundingClientRect();\n\n    link.coords = {\n      x1: (a.left + a.right) / 2 - ref.left,\n      y1: (a.top + a.bottom) / 2 - ref.top,\n      x2: (b.left + b.right) / 2 - ref.left,\n      y2: (b.top + b.bottom) / 2 - ref.top,\n    };\n  }\n\n  let svg = element.querySelector(\"svg\");\n  if (svg != null) {\n    element.removeChild(svg);\n  }\n\n  let box = element;\n  while (box.parentNode && box.offsetHeight === 0) {\n    box = box.parentNode;\n  }\n\n  svg = makeSVG();\n  svg.setAttribute(\"width\", box.offsetWidth);\n  svg.setAttribute(\"height\", box.offsetHeight);\n\n  for (link of Array.from(links)) {\n    const c = link.coords;\n\n    const line = makeSVG(\"path\");\n    line.setAttribute(\"d\", path(c.x1, c.y1, c.x2, c.y2));\n    line.setAttribute(\"stroke\", link.color);\n    line.setAttribute(\"stroke-width\", 3);\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.appendChild(line);\n  }\n\n  return element.appendChild(svg);\n};\n\nexport const overlay = function (contents) {\n  const div = document.createElement(\"div\");\n  div.setAttribute(\"class\", \"shadergraph-overlay\");\n\n  const close = document.createElement(\"div\");\n  close.setAttribute(\"class\", \"shadergraph-close\");\n  close.innerHTML = \"&times;\";\n\n  const view = document.createElement(\"div\");\n  view.setAttribute(\"class\", \"shadergraph-view\");\n\n  const inside = document.createElement(\"div\");\n  inside.setAttribute(\"class\", \"shadergraph-inside\");\n\n  inside.appendChild(contents);\n  view.appendChild(inside);\n  div.appendChild(view);\n  div.appendChild(close);\n\n  close.addEventListener(\"click\", () => div.parentNode.removeChild(div));\n\n  return div;\n};\n\nconst wrap = function (markup) {\n  if (markup instanceof Node) {\n    return markup;\n  }\n  const p = document.createElement(\"span\");\n  p.innerText = markup != null ? markup : \"\";\n  return p;\n};\n\nexport const merge = function (markup) {\n  if (markup.length !== 1) {\n    let el;\n    const div = document.createElement(\"div\");\n    for (el of Array.from(markup)) {\n      div.appendChild(wrap(el));\n    }\n    div.update = () =>\n      (() => {\n        const result = [];\n        for (el of Array.from(markup)) {\n          result.push(\n            typeof el.update === \"function\" ? el.update() : undefined\n          );\n        }\n        return result;\n      })();\n    return div;\n  } else {\n    return wrap(markup[0]);\n  }\n};\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\nimport { serialize as _serialize } from \"./serialize\";\nimport * as _markup from \"./markup\";\n\nexport const serialize = _serialize;\nexport const markup = _markup;\n\nconst _visualize = function (graph) {\n  if (!graph) {\n    return;\n  }\n  if (!graph.nodes) {\n    return graph;\n  }\n\n  const data = serialize(graph);\n  return markup.process(data);\n};\n\nvar resolve = function (arg) {\n  if (arg == null) {\n    return arg;\n  }\n  if (arg instanceof Array) {\n    return arg.map(resolve);\n  }\n  if (arg.vertex != null && arg.fragment != null) {\n    return [resolve(arg.vertex, resolve(arg.fragment))];\n  }\n  if (arg._graph != null) {\n    return arg._graph;\n  }\n  if (arg.graph != null) {\n    return arg.graph;\n  }\n  return arg;\n};\n\nvar merge = function (args) {\n  let out = [];\n  for (let arg of Array.from(args)) {\n    if (arg instanceof Array) {\n      out = out.concat(merge(arg));\n    } else if (arg != null) {\n      out.push(arg);\n    }\n  }\n  return out;\n};\n\nexport const visualize = function () {\n  const list = merge(resolve([].slice.call(arguments)));\n  return markup.merge(\n    Array.from(list)\n      .filter((graph) => graph)\n      .map((graph) => _visualize(graph))\n  );\n};\n\nexport const inspect = function () {\n  const contents = visualize.apply(null, arguments);\n  const element = markup.overlay(contents);\n\n  for (let el of Array.from(\n    document.querySelectorAll(\".shadergraph-overlay\")\n  )) {\n    el.remove();\n  }\n  document.body.appendChild(element);\n  contents.update();\n\n  return element;\n};\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS104: Avoid inline assignments\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Graph } from \"../graph\";\nimport * as Block from \"../block\";\nimport * as Visualize from \"../visualize\";\n\n/*\n  Chainable factory\n\n  Exposes methods to build a graph incrementally\n*/\nexport class Factory {\n  constructor(language, fetch, config) {\n    this.language = language;\n    this.fetch = fetch;\n    this.config = config;\n    this.graph();\n  }\n\n  // Combined call/concat shortcut\n  pipe(name, uniforms, namespace, defines) {\n    if (name instanceof Factory) {\n      this._concat(name);\n    } else if (name != null) {\n      this._call(name, uniforms, namespace, defines);\n    }\n    return this;\n  }\n\n  // Old name\n  call(name, uniforms, namespace, defines) {\n    return this.pipe(name, uniforms, namespace, defines);\n  }\n\n  // Combined callback/import shortcut\n  require(name, uniforms, namespace, defines) {\n    if (name instanceof Factory) {\n      this._import(name);\n    } else if (name != null) {\n      this.callback();\n      this._call(name, uniforms, namespace, defines);\n      this.end();\n    }\n    return this;\n  }\n\n  // Old name\n  import(name, uniforms, namespace, defines) {\n    return this.require(name, uniforms, namespace, defines);\n  }\n\n  // Create parallel branches that connect as one block to the end\n  // (one outgoing connection per outlet)\n  split() {\n    this._group(\"_combine\", true);\n    return this;\n  }\n\n  // Create parallel branches that fan out from the end\n  // (multiple outgoing connections per outlet)\n  fan() {\n    this._group(\"_combine\", false);\n    return this;\n  }\n\n  // Create isolated subgraph\n  isolate() {\n    this._group(\"_isolate\");\n    return this;\n  }\n\n  // Create callback subgraph\n  callback() {\n    this._group(\"_callback\");\n    return this;\n  }\n\n  // Next branch in group\n  next() {\n    this._next();\n    return this;\n  }\n\n  // Connect branches to previous tail and add pass-through from end\n  pass() {\n    const pass = this._stack[2].end;\n    this.end();\n    this._state.end = this._state.end.concat(pass);\n    return this;\n  }\n\n  // Leave nested branches and join up with main graph,\n  // applying stored op along the way\n  end() {\n    const [sub, main] = Array.from(this._exit());\n    const { op } = sub;\n    if (this[op]) {\n      this[op](sub, main);\n    }\n    return this;\n  }\n\n  // Old name\n  join() {\n    return this.end();\n  }\n\n  // Return finalized graph / reset factory\n  graph() {\n    // Pop remaining stack\n    while ((this._stack != null ? this._stack.length : undefined) > 1) {\n      this.end();\n    }\n\n    // Remember terminating node(s) of graph\n    if (this._graph) {\n      this._tail(this._state, this._graph);\n    }\n\n    const graph = this._graph;\n\n    this._graph = new Graph();\n    this._state = new State();\n    this._stack = [this._state];\n\n    return graph;\n  }\n\n  // Compile shortcut (graph is thrown away)\n  compile(namespace) {\n    if (namespace == null) {\n      namespace = \"main\";\n    }\n    return this.graph().compile(namespace);\n  }\n\n  // Link shortcut (graph is thrown away)\n  link(namespace) {\n    if (namespace == null) {\n      namespace = \"main\";\n    }\n    return this.graph().link(namespace);\n  }\n\n  // Serialize for debug\n  serialize() {\n    return Visualize.serialize(this._graph);\n  }\n\n  // Return true if empty\n  empty() {\n    return this._graph.nodes.length === 0;\n  }\n\n  // Concatenate existing factory onto tail\n  // Retains original factory\n  _concat(factory) {\n    // Ignore empty concat\n    let block;\n    if (factory._state.nodes.length === 0) {\n      return this;\n    }\n\n    this._tail(factory._state, factory._graph);\n\n    try {\n      block = new Block.Isolate(factory._graph);\n    } catch (error) {\n      if (this.config.autoInspect) {\n        Visualize.inspect(error, this._graph, factory);\n      }\n      throw error;\n    }\n\n    this._auto(block);\n    return this;\n  }\n\n  // Add existing factory as callback\n  // Retains original factory\n  _import(factory) {\n    // Check for empty require\n    let block;\n    if (factory._state.nodes.length === 0) {\n      throw \"Can't import empty callback\";\n    }\n\n    this._tail(factory._state, factory._graph);\n\n    try {\n      block = new Block.Callback(factory._graph);\n    } catch (error) {\n      if (this.config.autoInspect) {\n        Visualize.inspect(error, this._graph, factory);\n      }\n      throw error;\n    }\n\n    this._auto(block);\n    return this;\n  }\n\n  // Connect parallel branches to tail\n  _combine(sub, main) {\n    for (let to of Array.from(sub.start)) {\n      for (let from of Array.from(main.end)) {\n        from.connect(to, sub.multi);\n      }\n    }\n\n    main.end = sub.end;\n    return (main.nodes = main.nodes.concat(sub.nodes));\n  }\n\n  // Make subgraph and connect to tail\n  _isolate(sub, main) {\n    if (sub.nodes.length) {\n      let block;\n      const subgraph = this._subgraph(sub);\n      this._tail(sub, subgraph);\n\n      try {\n        block = new Block.Isolate(subgraph);\n      } catch (error) {\n        if (this.config.autoInspect) {\n          Visualize.inspect(error, this._graph, subgraph);\n        }\n        throw error;\n      }\n\n      return this._auto(block);\n    }\n  }\n\n  // Convert to callback and connect to tail\n  _callback(sub, main) {\n    if (sub.nodes.length) {\n      let block;\n      const subgraph = this._subgraph(sub);\n      this._tail(sub, subgraph);\n\n      try {\n        block = new Block.Callback(subgraph);\n      } catch (error) {\n        if (this.config.autoInspect) {\n          Visualize.inspect(error, this._graph, subgraph);\n        }\n        throw error;\n      }\n\n      return this._auto(block);\n    }\n  }\n\n  // Create next call block\n  _call(name, uniforms, namespace, defines) {\n    const snippet = this.fetch(name);\n    snippet.bind(this.config, uniforms, namespace, defines);\n    const block = new Block.Call(snippet);\n    return this._auto(block);\n  }\n\n  // Move current state into subgraph\n  _subgraph(sub) {\n    const subgraph = new Graph(null, this._graph);\n    subgraph.adopt(sub.nodes);\n    return subgraph;\n  }\n\n  // Finalize graph tail\n  _tail(state, graph) {\n    // Merge (unique) terminating ends into single tail node if needed\n    let tail = state.end.concat(state.tail);\n    tail = tail.filter((node, i) => tail.indexOf(node) === i);\n\n    if (tail.length > 1) {\n      tail = new Block.Join(tail);\n      tail = [tail.node];\n      this._graph.add(tail);\n    }\n\n    // Save single endpoint\n    graph.tail = tail[0];\n    state.end = tail;\n    state.tail = [];\n\n    if (!graph.tail) {\n      throw new Error(\"Cannot finalize empty graph\");\n    }\n\n    // Add compile/link/export/inspect shortcut methods\n    graph.compile = (namespace) => {\n      if (namespace == null) {\n        namespace = \"main\";\n      }\n      try {\n        return graph.tail.owner.compile(this.language, namespace);\n      } catch (error) {\n        if (this.config.autoInspect) {\n          graph.inspect(error);\n        }\n        throw error;\n      }\n    };\n\n    graph.link = (namespace) => {\n      if (namespace == null) {\n        namespace = \"main\";\n      }\n      try {\n        return graph.tail.owner.link(this.language, namespace);\n      } catch (error) {\n        if (this.config.autoInspect) {\n          graph.inspect(error);\n        }\n        throw error;\n      }\n    };\n\n    graph.export = (layout, depth) => {\n      return graph.tail.owner.export(layout, depth);\n    };\n\n    return (graph.inspect = (message = null) =>\n      Visualize.inspect(message, graph));\n  }\n\n  // Create group for branches or callbacks\n  _group(op, multi) {\n    this._push(op, multi); // Accumulator\n    this._push(); // Current\n    return this;\n  }\n\n  // Merge branch into accumulator and reset state\n  _next() {\n    const sub = this._pop();\n\n    this._state.start = this._state.start.concat(sub.start);\n    this._state.end = this._state.end.concat(sub.end);\n    this._state.nodes = this._state.nodes.concat(sub.nodes);\n    this._state.tail = this._state.tail.concat(sub.tail);\n\n    return this._push();\n  }\n\n  // Exit nested branches\n  _exit() {\n    this._next();\n    this._pop();\n    return [this._pop(), this._state];\n  }\n\n  // State stack\n  _push(op, multi) {\n    this._stack.unshift(new State(op, multi));\n    return (this._state = this._stack[0]);\n  }\n\n  _pop() {\n    let left;\n    this._state = this._stack[1];\n    if (this._state == null) {\n      this._state = new State();\n    }\n    return (left = this._stack.shift()) != null ? left : new State();\n  }\n\n  // Auto append or insert depending on whether we have inputs\n  _auto(block) {\n    if (block.node.inputs.length) {\n      return this._append(block);\n    } else {\n      return this._insert(block);\n    }\n  }\n\n  // Add block and connect to end\n  _append(block) {\n    let end;\n    const { node } = block;\n    this._graph.add(node);\n\n    for (end of Array.from(this._state.end)) {\n      end.connect(node);\n    }\n\n    if (!this._state.start.length) {\n      this._state.start = [node];\n    }\n    this._state.end = [node];\n\n    this._state.nodes.push(node);\n    if (!node.outputs.length) {\n      this._state.tail.push(node);\n    }\n  }\n\n  // Add block and connect to start\n  _prepend(block) {\n    let start;\n    const { node } = block;\n    this._graph.add(node);\n\n    for (start of Array.from(this._state.start)) {\n      node.connect(start);\n    }\n\n    if (!this._state.end.length) {\n      this._state.end = [node];\n    }\n    this._state.start = [node];\n\n    this._state.nodes.push(node);\n    if (!node.outputs.length) {\n      this._state.tail.push(node);\n    }\n  }\n\n  // Insert loose block\n  _insert(block) {\n    const { node } = block;\n    this._graph.add(node);\n\n    this._state.start.push(node);\n    this._state.end.push(node);\n\n    this._state.nodes.push(node);\n    if (!node.outputs.length) {\n      return this._state.tail.push(node);\n    }\n  }\n}\n\nclass State {\n  constructor(op = null, multi, start, end, nodes, tail) {\n    this.op = op;\n    if (multi == null) {\n      multi = false;\n    }\n    this.multi = multi;\n    if (start == null) {\n      start = [];\n    }\n    this.start = start;\n    if (end == null) {\n      end = [];\n    }\n    this.end = end;\n    if (nodes == null) {\n      nodes = [];\n    }\n    this.nodes = nodes;\n    if (tail == null) {\n      tail = [];\n    }\n    this.tail = tail;\n  }\n}\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\nimport * as Visualize from \"../visualize\";\n\nlet debug = false;\n\nconst tick = function () {\n  const now = +new Date();\n  return function (label) {\n    const delta = +new Date() - now;\n    console.log(label, delta + \" ms\");\n    return delta;\n  };\n};\n\nexport class Material {\n  constructor(vertex, fragment) {\n    this.vertex = vertex;\n    this.fragment = fragment;\n    if (debug) {\n      this.tock = tick();\n    }\n  }\n\n  build(options) {\n    return this.link(options);\n  }\n\n  link(options) {\n    if (options == null) {\n      options = {};\n    }\n    const uniforms = {};\n    const varyings = {};\n    const attributes = {};\n\n    const vertex = this.vertex.link(\"main\");\n    const fragment = this.fragment.link(\"main\");\n\n    for (let shader of [vertex, fragment]) {\n      var key, value;\n      for (key in shader.uniforms) {\n        value = shader.uniforms[key];\n        uniforms[key] = value;\n      }\n      for (key in shader.varyings) {\n        value = shader.varyings[key];\n        varyings[key] = value;\n      }\n      for (key in shader.attributes) {\n        value = shader.attributes[key];\n        attributes[key] = value;\n      }\n    }\n\n    options.vertexShader = vertex.code;\n    options.vertexGraph = vertex.graph;\n    options.fragmentShader = fragment.code;\n    options.fragmentGraph = fragment.graph;\n    options.attributes = attributes;\n    options.uniforms = uniforms;\n    options.varyings = varyings;\n    options.inspect = () =>\n      Visualize.inspect(\n        \"Vertex Shader\",\n        vertex,\n        \"Fragment Shader\",\n        fragment.graph\n      );\n\n    if (debug) {\n      this.tock(\"Material build\");\n    }\n\n    return options;\n  }\n\n  inspect() {\n    return Visualize.inspect(\n      \"Vertex Shader\",\n      this.vertex,\n      \"Fragment Shader\",\n      this.fragment.graph\n    );\n  }\n}\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n/*\n  Snippet library\n\n  Takes:\n    - Hash of snippets: named library\n    - (name) -> getter: dynamic lookup\n    - nothing:          no library, only pass in inline source code\n\n  If 'name' contains any of \"{;(#\" it is assumed to be direct GLSL code.\n*/\nexport const library = function (language, snippets, load) {\n  let callback = null;\n  let used = {};\n\n  if (snippets != null) {\n    if (typeof snippets === \"function\") {\n      callback = (name) => load(language, name, snippets(name));\n    } else if (typeof snippets === \"object\") {\n      callback = function (name) {\n        if (snippets[name] == null) {\n          throw new Error(`Unknown snippet \\`${name}\\``);\n        }\n        return load(language, name, snippets[name]);\n      };\n    }\n  }\n\n  const inline = (code) => load(language, \"\", code);\n\n  if (callback == null) {\n    return inline;\n  }\n\n  const fetch = function (name) {\n    if (name.match(/[{;]/)) {\n      return inline(name);\n    }\n    used[name] = true;\n    return callback(name);\n  };\n\n  fetch.used = function (_used) {\n    if (_used == null) {\n      _used = used;\n    }\n    return (used = _used);\n  };\n\n  return fetch;\n};\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// Least-recently-used queue for key expiry via linked list\nexport const queue = function (limit) {\n  if (limit == null) {\n    limit = 100;\n  }\n  const map = {};\n\n  let head = null;\n  let tail = null;\n  let count = 0;\n\n  // Insert at front\n  const add = function (item) {\n    item.prev = null;\n    item.next = head;\n\n    if (head != null) {\n      head.prev = item;\n    }\n\n    head = item;\n    if (tail == null) {\n      return (tail = item);\n    }\n  };\n\n  // Remove from list\n  const remove = function (item) {\n    const { prev } = item;\n    const { next } = item;\n\n    if (prev != null) {\n      prev.next = next;\n    }\n    if (next != null) {\n      next.prev = prev;\n    }\n\n    if (head === item) {\n      head = next;\n    }\n    if (tail === item) {\n      return (tail = prev);\n    }\n  };\n\n  // Push key to top of list\n  return function (key) {\n    let dead, item;\n    if ((item = map[key]) && item !== head) {\n      // Already in queue\n      remove(item);\n      add(item);\n    } else {\n      // Check capacity\n      if (count === limit) {\n        // Pop tail\n        dead = tail.key;\n        remove(tail);\n\n        // Expire key\n        delete map[dead];\n      } else {\n        count++;\n      }\n\n      // Replace head\n      item = { next: head, prev: null, key };\n      add(item);\n\n      // Map record for lookup\n      map[key] = item;\n    }\n\n    // Return expired key\n    return dead;\n  };\n};\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n/*\n  Cache decorator\n  Fetches snippets once, clones for reuse\n  Inline code is hashed to avoid bloat\n*/\nimport { queue } from \"./queue\";\nimport { hash } from \"./hash\";\n\nexport const cache = function (fetch) {\n  const cached = {};\n  const push = queue(100);\n\n  // Snippet factory\n  return function (name) {\n    const key = name.length > 32 ? \"##\" + hash(name).toString(16) : name;\n\n    // Push new key onto queue, see if an old key expired\n    const expire = push(key);\n    if (expire != null) {\n      delete cached[expire];\n    }\n\n    // Clone cached snippet\n    if (cached[key] == null) {\n      cached[key] = fetch(name);\n    }\n    return cached[key].clone();\n  };\n};\n","export * from \"./factory\";\nexport * from \"./material\";\n\nexport * from \"./library\";\nexport * from \"./cache\";\nexport * from \"./queue\";\nexport * from \"./hash\";\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n/*\n  Compile snippet back into GLSL, but with certain symbols replaced by prefixes / placeholders\n*/\n\nexport const compile = function (program) {\n  const { ast, code, signatures } = program;\n\n  // Prepare list of placeholders\n  const placeholders = replaced(signatures);\n\n  // Compile\n  const assembler = string_compiler(code, placeholders);\n\n  return [signatures, assembler];\n};\n\n// #####\n\nconst tick = function () {\n  const now = +new Date();\n  return function (label) {\n    const delta = +new Date() - now;\n    console.log(label, delta + \" ms\");\n    return delta;\n  };\n};\n\nvar replaced = function (signatures) {\n  const out = {};\n  const s = (sig) => (out[sig.name] = true);\n\n  s(signatures.main);\n\n  // Prefix all global symbols\n  for (let key of [\"external\", \"internal\", \"varying\", \"uniform\", \"attribute\"]) {\n    for (let sig of signatures[key]) {\n      s(sig);\n    }\n  }\n\n  return out;\n};\n\n/*\nString-replacement based compiler\n*/\nvar string_compiler = function (code, placeholders) {\n  // Make regexp for finding placeholders\n  // Replace on word boundaries\n  let key;\n  const re = new RegExp(\n    \"\\\\b(\" +\n      (() => {\n        const result = [];\n        for (key in placeholders) {\n          result.push(key);\n        }\n        return result;\n      })().join(\"|\") +\n      \")\\\\b\",\n    \"g\"\n  );\n\n  // Strip comments\n  code = code.replace(/\\/\\/[^\\n]*/g, \"\");\n  code = code.replace(/\\/\\*([^*]|\\*[^\\/])*\\*\\//g, \"\");\n\n  // Strip all preprocessor commands (lazy)\n  //code = code.replace /^#[^\\n]*/mg, ''\n\n  // Assembler function that takes namespace prefix and exceptions\n  // and returns GLSL source code\n  return function (prefix, exceptions, defines) {\n    let key;\n    if (prefix == null) {\n      prefix = \"\";\n    }\n    if (exceptions == null) {\n      exceptions = {};\n    }\n    if (defines == null) {\n      defines = {};\n    }\n    const replace = {};\n    for (key in placeholders) {\n      replace[key] = exceptions[key] != null ? key : prefix + key;\n    }\n\n    const compiled = code.replace(re, (key) => replace[key]);\n\n    const defs = (() => {\n      const result1 = [];\n      for (key in defines) {\n        const value = defines[key];\n        result1.push(`#define ${key} ${value}`);\n      }\n      return result1;\n    })();\n    if (defs.length) {\n      defs.push(\"\");\n    }\n    return defs.join(\"\\n\") + compiled;\n  };\n};\n","class Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector2.prototype.isVector2 = true;\n\nexport { Vector2 };\n","const _lut = [];\n\nfor ( let i = 0; i < 256; i ++ ) {\n\n\t_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );\n\n}\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toUpperCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidian modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t\t } else {\n\n\t\treturn 0;\n\n\t\t }\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s % 2147483647;\n\n\t// Park-Miller algorithm\n\n\t_seed = _seed * 16807 % 2147483647;\n\n\treturn ( _seed - 1 ) / 2147483646;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\n\n\n\nexport {\n\tDEG2RAD,\n\tRAD2DEG,\n\tgenerateUUID,\n\tclamp,\n\teuclideanModulo,\n\tmapLinear,\n\tinverseLerp,\n\tlerp,\n\tdamp,\n\tpingpong,\n\tsmoothstep,\n\tsmootherstep,\n\trandInt,\n\trandFloat,\n\trandFloatSpread,\n\tseededRandom,\n\tdegToRad,\n\tradToDeg,\n\tisPowerOfTwo,\n\tceilPowerOfTwo,\n\tfloorPowerOfTwo,\n\tsetQuaternionFromProperEuler,\n};\n","import * as MathUtils from './MathUtils.js';\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerp( qa, qb, qm, t ) {\n\n\t\tconsole.warn( 'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.' );\n\t\treturn qm.slerpQuaternions( qa, qb, t );\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize();\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\tthis.copy( qa ).slerp( qb, t );\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n}\n\nQuaternion.prototype.isQuaternion = true;\n\nexport { Quaternion };\n","import * as MathUtils from './MathUtils.js';\nimport { Quaternion } from './Quaternion.js';\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\treturn this.applyQuaternion( _quaternion.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( MathUtils.clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index, offset ) {\n\n\t\tif ( offset !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\n\n\t\t}\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n}\n\nVector3.prototype.isVector3 = true;\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\n\nexport { Vector3 };\n","class Matrix3 {\n\n\tconstructor() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tscale( sx, sy ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\n\t\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tconst te = this.elements;\n\n\t\tconst a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\n\t\tconst a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\n\n\t\tte[ 0 ] = c * a11 + s * a21;\n\t\tte[ 3 ] = c * a12 + s * a22;\n\t\tte[ 6 ] = c * a13 + s * a23;\n\n\t\tte[ 1 ] = - s * a11 + c * a21;\n\t\tte[ 4 ] = - s * a12 + c * a22;\n\t\tte[ 7 ] = - s * a13 + c * a23;\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\n\t\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nMatrix3.prototype.isMatrix3 = true;\n\nexport { Matrix3 };\n","import { Vector3 } from './Vector3.js';\n\nclass Matrix4 {\n\n\tconstructor() {\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( arguments.length > 0 ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tif ( ! ( euler && euler.isEuler ) ) {\n\n\t\t\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\n\n\t\t}\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1.elements[ 0 ] *= invSX;\n\t\t_m1.elements[ 1 ] *= invSX;\n\t\t_m1.elements[ 2 ] *= invSX;\n\n\t\t_m1.elements[ 4 ] *= invSY;\n\t\t_m1.elements[ 5 ] *= invSY;\n\t\t_m1.elements[ 6 ] *= invSY;\n\n\t\t_m1.elements[ 8 ] *= invSZ;\n\t\t_m1.elements[ 9 ] *= invSZ;\n\t\t_m1.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far ) {\n\n\t\tif ( far === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\n\n\t\t}\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\t\tconst c = - ( far + near ) / ( far - near );\n\t\tconst d = - 2 * far * near / ( far - near );\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\t\tconst z = ( far + near ) * p;\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nMatrix4.prototype.isMatrix4 = true;\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nexport { Matrix4 };\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n// AST node parsers\n\nimport { Vector2 } from \"three/src/math/Vector2.js\";\nimport { Vector3 } from \"three/src/math/Vector3.js\";\nimport { Vector4 } from \"three/src/math/Vector3.js\";\nimport { Matrix3 } from \"three/src/math/Matrix3.js\";\nimport { Matrix4 } from \"three/src/math/Matrix4.js\";\n\nexport let decl = {};\n\ndecl.in = 0;\ndecl.out = 1;\ndecl.inout = 2;\n\nconst get = (n) => n.token.data;\n\ndecl.node = function (node) {\n  if (\n    (node.children[5] != null ? node.children[5].type : undefined) ===\n    \"function\"\n  ) {\n    return decl.function(node);\n  } else if ((node.token != null ? node.token.type : undefined) === \"keyword\") {\n    return decl.external(node);\n  }\n};\n\ndecl.external = function (node) {\n  //    console.log 'external', node\n  let c = node.children;\n\n  let storage = get(c[1]);\n  const struct = get(c[3]);\n  const type = get(c[4]);\n  const list = c[5];\n\n  if (![\"attribute\", \"uniform\", \"varying\"].includes(storage)) {\n    storage = \"global\";\n  }\n\n  const out = [];\n\n  for (let i = 0; i < list.children.length; i++) {\n    c = list.children[i];\n    if (c.type === \"ident\") {\n      const ident = get(c);\n      const next = list.children[i + 1];\n      const quant = (next != null ? next.type : undefined) === \"quantifier\";\n\n      out.push({\n        decl: \"external\",\n        storage,\n        type,\n        ident,\n        quant: !!quant,\n        count: quant,\n      });\n    }\n  }\n\n  return out;\n};\n\ndecl.function = function (node) {\n  const c = node.children;\n\n  //    console.log 'function', node\n\n  const storage = get(c[1]);\n  const struct = get(c[3]);\n  const type = get(c[4]);\n  const func = c[5];\n  const ident = get(func.children[0]);\n  const args = func.children[1];\n  const body = func.children[2];\n\n  const decls = Array.from(args.children).map((child) => decl.argument(child));\n\n  return [\n    {\n      decl: \"function\",\n      storage,\n      type,\n      ident,\n      body: !!body,\n      args: decls,\n    },\n  ];\n};\n\ndecl.argument = function (node) {\n  const c = node.children;\n\n  //    console.log 'argument', node\n\n  const storage = get(c[1]);\n  const inout = get(c[2]);\n  const type = get(c[4]);\n  const list = c[5];\n  const ident = get(list.children[0]);\n  const quant = list.children[1];\n\n  const count = quant ? quant.children[0].token.data : undefined;\n\n  return {\n    decl: \"argument\",\n    storage,\n    inout,\n    type,\n    ident,\n    quant: !!quant,\n    count,\n  };\n};\n\ndecl.param = function (dir, storage, spec, quant, count) {\n  let prefix = [];\n  if (storage != null) {\n    prefix.push(storage);\n  }\n  if (spec != null) {\n    prefix.push(spec);\n  }\n  prefix.push(\"\");\n\n  prefix = prefix.join(\" \");\n  const suffix = quant ? \"[\" + count + \"]\" : \"\";\n  if (dir !== \"\") {\n    dir += \" \";\n  }\n\n  const f = (name, long) => (long ? dir : \"\") + `${prefix}${name}${suffix}`;\n  f.split = (dir) => decl.param(dir, storage, spec, quant, count);\n\n  return f;\n};\n\n// Three.js sugar\nconst win = typeof window !== \"undefined\";\nconst threejs = win && !!window.THREE;\n\nconst defaults = {\n  int: 0,\n  float: 0,\n  vec2: threejs ? Vector2 : null,\n  vec3: threejs ? Vector3 : null,\n  vec4: threejs ? Vector4 : null,\n  mat2: null,\n  mat3: threejs ? Matrix3 : null,\n  mat4: threejs ? Matrix4 : null,\n  sampler2D: 0,\n  samplerCube: 0,\n};\n\nconst three = {\n  int: \"i\",\n  float: \"f\",\n  vec2: \"v2\",\n  vec3: \"v3\",\n  vec4: \"v4\",\n  mat2: \"m2\",\n  mat3: \"m3\",\n  mat4: \"m4\",\n  sampler2D: \"t\",\n  samplerCube: \"t\",\n};\n\ndecl.type = function (name, spec, quant, count, dir, storage) {\n  const dirs = {\n    in: decl.in,\n    out: decl.out,\n    inout: decl.inout,\n  };\n\n  const storages = { const: \"const\" };\n\n  let type = three[spec];\n  if (quant) {\n    type += \"v\";\n  }\n\n  let value = defaults[spec];\n  if (value != null ? value.call : undefined) {\n    value = new value();\n  }\n  if (quant) {\n    value = [value];\n  }\n\n  const inout = dirs[dir] != null ? dirs[dir] : dirs.in;\n  storage = storages[storage];\n\n  const param = decl.param(dir, storage, spec, quant, count);\n  return new Definition(name, type, spec, param, value, inout);\n};\n\nclass Definition {\n  constructor(name, type, spec, param, value, inout, meta) {\n    this.name = name;\n    this.type = type;\n    this.spec = spec;\n    this.param = param;\n    this.value = value;\n    this.inout = inout;\n    this.meta = meta;\n  }\n\n  split() {\n    // Split inouts\n    const isIn = this.meta.shadowed != null;\n    const dir = isIn ? \"in\" : \"out\";\n    const inout = isIn ? decl.in : decl.out;\n    const param = this.param.split(dir);\n    return new Definition(\n      this.name,\n      this.type,\n      this.spec,\n      param,\n      this.value,\n      inout\n    );\n  }\n\n  copy(name, meta) {\n    let def;\n    return (def = new Definition(\n      name != null ? name : this.name,\n      this.type,\n      this.spec,\n      this.param,\n      this.value,\n      this.inout,\n      meta\n    ));\n  }\n}\n","export const SHADOW_ARG = \"_i_o\";\nexport const RETURN_ARG = \"return\";\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS201: Simplify complex destructure assignments\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport tokenize from \"glsl-tokenizer/string\";\nimport parser from \"glsl-parser/direct\";\nimport { decl } from \"./decl\";\nimport { SHADOW_ARG, RETURN_ARG } from \"./constants\";\n\nlet debug = false;\n\n/*\nparse GLSL into AST\nextract all global symbols and make type signatures\n*/\n// Parse a GLSL snippet\nexport const parse = function (name, code) {\n  const ast = parseGLSL(name, code);\n  return processAST(ast, code);\n};\n\n// Parse GLSL language into AST\nvar parseGLSL = function (name, code) {\n  let ast, tock;\n  let errors = [];\n  if (debug) {\n    tock = tick();\n  }\n\n  try {\n    const tokens = tokenize(code);\n    ast = parser(tokens);\n  } catch (e) {\n    errors = [{ message: e }];\n  }\n\n  if (debug) {\n    tock(\"GLSL Tokenize & Parse\");\n  }\n\n  const fmt = function (code) {\n    code = code.split(\"\\n\");\n    const max = (\"\" + code.length).length;\n    const pad = function (v) {\n      if ((v = \"\" + v).length < max) {\n        return (\"       \" + v).slice(-max);\n      } else {\n        return v;\n      }\n    };\n    return code.map((line, i) => `${pad(i + 1)}: ${line}`).join(\"\\n\");\n  };\n\n  if (!ast || errors.length) {\n    if (!name) {\n      name = \"(inline code)\";\n    }\n    console.warn(fmt(code));\n    for (let error of errors) {\n      console.error(`${name} -`, error.message);\n    }\n    throw new Error(\"GLSL parse error\");\n  }\n\n  return ast;\n};\n\n// Process AST for compilation\nvar processAST = function (ast, code) {\n  let tock;\n  if (debug) {\n    tock = tick();\n  }\n\n  // Walk AST tree and collect global declarations\n  const symbols = [];\n  walk(mapSymbols, collect(symbols), ast, \"\");\n\n  // Sort symbols into bins\n  const [main, internals, externals] = Array.from(sortSymbols(symbols));\n\n  // Extract storage/type signatures of symbols\n  const signatures = extractSignatures(main, internals, externals);\n\n  if (debug) {\n    tock(\"GLSL AST\");\n  }\n\n  return { ast, code, signatures };\n};\n\n// Extract functions and external symbols from AST\nvar mapSymbols = function (node, collect) {\n  switch (node.type) {\n    case \"decl\":\n      collect(decl.node(node));\n      return false;\n  }\n  return true;\n};\n\nconst collect = (out) =>\n  function (value) {\n    if (value != null) {\n      Array.from(value).map((obj) => out.push(obj));\n    }\n  };\n\n// Identify internals, externals and main function\nvar sortSymbols = function (symbols) {\n  let main = null;\n  const internals = [];\n  let externals = [];\n  const maybe = {};\n  let found = false;\n\n  for (var s of Array.from(symbols)) {\n    if (!s.body) {\n      // Unmarked globals are definitely internal\n      if (s.storage === \"global\") {\n        internals.push(s);\n\n        // Possible external\n      } else {\n        externals.push(s);\n        maybe[s.ident] = true;\n      }\n    } else {\n      // Remove earlier forward declaration\n      if (maybe[s.ident]) {\n        externals = Array.from(externals).filter((e) => e.ident !== s.ident);\n        delete maybe[s.ident];\n      }\n\n      // Internal function\n      internals.push(s);\n\n      // Last function is main\n      // unless there is a function called 'main'\n      if (s.ident === \"main\") {\n        main = s;\n        found = true;\n      } else if (!found) {\n        main = s;\n      }\n    }\n  }\n\n  return [main, internals, externals];\n};\n\n// Generate type signatures and appropriate ins/outs\nvar extractSignatures = function (main, internals, externals) {\n  let symbol;\n  const sigs = {\n    uniform: [],\n    attribute: [],\n    varying: [],\n    external: [],\n    internal: [],\n    global: [],\n    main: null,\n  };\n\n  const defn = (symbol) =>\n    decl.type(\n      symbol.ident,\n      symbol.type,\n      symbol.quant,\n      symbol.count,\n      symbol.inout,\n      symbol.storage\n    );\n\n  const func = function (symbol, inout) {\n    let d;\n    const signature = Array.from(symbol.args).map((arg) => defn(arg));\n\n    // Split inouts into in and out\n    for (d of Array.from(signature)) {\n      if (d.inout === decl.inout) {\n        const a = d;\n        const b = d.copy();\n\n        a.inout = decl.in;\n        b.inout = decl.out;\n        b.meta = { shadow: a.name };\n        b.name += SHADOW_ARG;\n        a.meta = { shadowed: b.name };\n\n        signature.push(b);\n      }\n    }\n\n    // Add output for return type\n    if (symbol.type !== \"void\") {\n      signature.unshift(decl.type(RETURN_ARG, symbol.type, false, \"\", \"out\"));\n    }\n\n    // Make type string\n    const inTypes = (() => {\n      const result = [];\n      for (d of Array.from(signature)) {\n        if (d.inout === decl.in) {\n          result.push(d.type);\n        }\n      }\n      return result;\n    })().join(\",\");\n    const outTypes = (() => {\n      const result1 = [];\n      for (d of Array.from(signature)) {\n        if (d.inout === decl.out) {\n          result1.push(d.type);\n        }\n      }\n      return result1;\n    })().join(\",\");\n    const type = `(${inTypes})(${outTypes})`;\n\n    return {\n      name: symbol.ident,\n      type,\n      signature,\n      inout,\n      spec: symbol.type,\n    };\n  };\n\n  // Main\n  sigs.main = func(main, decl.out);\n\n  // Internals (for name replacement only)\n  for (symbol of Array.from(internals)) {\n    sigs.internal.push({\n      name: symbol.ident,\n    });\n  }\n\n  // Externals\n  for (symbol of Array.from(externals)) {\n    switch (symbol.decl) {\n      // Uniforms/attributes/varyings\n      case \"external\":\n        var def = defn(symbol);\n        sigs[symbol.storage].push(def);\n        break;\n\n      // Callbacks\n      case \"function\":\n        def = func(symbol, decl.in);\n        sigs.external.push(def);\n        break;\n    }\n  }\n\n  return sigs;\n};\n\n// Walk AST, apply map and collect values\ndebug = false;\n\nexport var walk = function (map, collect, node, indent) {\n  debug &&\n    console.log(\n      indent,\n      node.type,\n      node.token != null ? node.token.data : undefined,\n      node.token != null ? node.token.type : undefined\n    );\n\n  const recurse = map(node, collect);\n\n  if (recurse) {\n    for (let i = 0; i < node.children.length; i++) {\n      const child = node.children[i];\n      walk(map, collect, child, indent + \"  \", debug);\n    }\n  }\n\n  return null;\n};\n\n// #####\n\nvar tick = function () {\n  const now = +new Date();\n  return function (label) {\n    const delta = +new Date() - now;\n    console.log(label, delta + \" ms\");\n    return delta;\n  };\n};\n","/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS205: Consider reworking code to avoid use of IIFEs\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\nimport * as Graph from \"../graph\";\nimport * as $ from \"./constants\";\n\n/*\n  GLSL code generator for compiler and linker stubs\n*/\n\n// Check if shadow outlet\nexport function unshadow(name) {\n  const real = name.replace($.SHADOW_ARG, \"\");\n  if (real !== name) {\n    return real;\n  } else {\n    return null;\n  }\n}\n\n// Line joiners\nexport function lines(lines) {\n  return lines.join(\"\\n\");\n}\nexport function list(lines) {\n  return lines.join(\", \");\n}\nexport function statements(lines) {\n  return lines.join(\";\\n\");\n}\n\n// Function body\nexport function body(entry) {\n  return {\n    entry,\n    type: \"void\",\n    params: [],\n    signature: [],\n    return: \"\",\n    vars: {},\n    calls: [],\n    post: [],\n    chain: {},\n  };\n}\n\n// Symbol define\nexport function define(a, b) {\n  return `#define ${a} ${b}`;\n}\n\n// Function define\nexport function fn(type, entry, params, vars, calls) {\n  return `${type} ${entry}(${params}) {\\n${vars}${calls}}`;\n}\n\n// Function invocation\nexport function invoke(ret, entry, args) {\n  ret = ret ? `${ret} = ` : \"\";\n  args = list(args);\n  return `  ${ret}${entry}(${args})`;\n}\n\n// Compare two signatures\nexport function same(a, b) {\n  for (let i = 0; i < a.length; i++) {\n    const A = a[i];\n    const B = b[i];\n    if (!B) {\n      return false;\n    }\n    if (A.type !== B.type) {\n      return false;\n    }\n    if ((A.name === $.RETURN_ARG) !== (B.name === $.RETURN_ARG)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Generate call signature for module invocation\nexport function call(lookup, dangling, entry, signature, body) {\n  const args = [];\n  let ret = \"\";\n  const rets = 1;\n\n  for (let arg of Array.from(signature)) {\n    var id, shadow;\n    const { name } = arg;\n\n    let copy = (id = lookup(name));\n    let other = null;\n    let meta = null;\n    let omit = false;\n    const { inout } = arg;\n\n    const isReturn = name === $.RETURN_ARG;\n\n    // Shadowed inout: input side\n    if ((shadow = arg.meta != null ? arg.meta.shadowed : undefined)) {\n      other = lookup(shadow);\n      if (other) {\n        body.vars[other] = \"  \" + arg.param(other);\n        body.calls.push(`  ${other} = ${id}`);\n\n        if (!dangling(shadow)) {\n          arg = arg.split();\n        } else {\n          meta = { shadowed: other };\n        }\n      }\n    }\n\n    // Shadowed inout: output side\n    if ((shadow = arg.meta != null ? arg.meta.shadow : undefined)) {\n      other = lookup(shadow);\n      if (other) {\n        if (!dangling(shadow)) {\n          arg = arg.split();\n          omit = true;\n        } else {\n          meta = { shadow: other };\n          continue;\n        }\n      }\n    }\n\n    if (isReturn) {\n      // Capture return value\n      ret = id;\n    } else if (!omit) {\n      // Pass all non return, non shadow args in\n      args.push(other != null ? other : id);\n    }\n\n    // Export argument if unconnected\n    if (dangling(name)) {\n      let op = \"push\";\n      if (isReturn) {\n        if (body.return === \"\") {\n          op = \"unshift\";\n          // Preserve 'return' arg name\n          copy = name;\n          body.type = arg.spec;\n          body.return = `  return ${id}`;\n          body.vars[id] = \"  \" + arg.param(id);\n        } else {\n          body.vars[id] = \"  \" + arg.param(id);\n          body.params.push(arg.param(id, true));\n        }\n      } else {\n        body.params.push(arg.param(id, true));\n      }\n\n      // Copy argument into new signature\n      arg = arg.copy(copy, meta);\n      body.signature[op](arg);\n    } else {\n      body.vars[id] = \"  \" + arg.param(id);\n    }\n  }\n\n  return body.calls.push(invoke(ret, entry, args));\n}\n\n// Assemble main() function from body and call reference\nexport function build(body, calls) {\n  const { entry } = body;\n  let code = null;\n\n  // Check if we're only calling one snippet with identical signature\n  // and not building void main();\n  if (calls && calls.length === 1 && entry !== \"main\") {\n    const a = body;\n    const b = calls[0].module;\n\n    if (same(body.signature, b.main.signature)) {\n      code = define(entry, b.entry);\n    }\n  }\n\n  // Otherwise build function body\n  if (code == null) {\n    let vars = (() => {\n      const result = [];\n      for (let v in body.vars) {\n        const decl = body.vars[v];\n        result.push(decl);\n      }\n      return result;\n    })();\n    ({ calls } = body);\n    const { post } = body;\n    let { params } = body;\n    const { type } = body;\n    const ret = body.return;\n\n    calls = calls.concat(post);\n    if (ret !== \"\") {\n      calls.push(ret);\n    }\n    calls.push(\"\");\n\n    if (vars.length) {\n      vars.push(\"\");\n      vars = statements(vars) + \"\\n\";\n    } else {\n      vars = \"\";\n    }\n\n    calls = statements(calls);\n    params = list(params);\n\n    code = fn(type, entry, params, vars, calls);\n  }\n\n  return {\n    signature: body.signature,\n    code,\n    name: entry,\n  };\n}\n\n// Build links to other callbacks\nexport function links(links) {\n  const out = {\n    defs: [],\n    bodies: [],\n  };\n\n  for (let l of Array.from(links)) {\n    link(l, out);\n  }\n\n  out.defs = lines(out.defs);\n  out.bodies = statements(out.bodies);\n\n  if (out.defs === \"\") {\n    delete out.defs;\n  }\n  if (out.bodies === \"\") {\n    delete out.bodies;\n  }\n\n  return out;\n}\n\n// Link a module's entry point as a callback\nexport const link = (link, out) => {\n  let arg, list;\n  const { module, name, external } = link;\n  const { main } = module;\n  const { entry } = module;\n\n  // If signatures match, #define alias for the symbol\n  if (same(main.signature, external.signature)) {\n    return out.defs.push(define(name, entry));\n  }\n\n  // Signatures differ, build one-line callback to match defined prototype\n\n  // Map names to names\n  const ins = [];\n  const outs = [];\n  let map = {};\n  const returnVar = [module.namespace, $.RETURN_ARG].join(\"\");\n\n  for (arg of Array.from(external.signature)) {\n    list = arg.inout === Graph.IN ? ins : outs;\n    list.push(arg);\n  }\n\n  for (arg of Array.from(main.signature)) {\n    list = arg.inout === Graph.IN ? ins : outs;\n    const other = list.shift();\n    let _name = other.name;\n\n    // Avoid 'return' keyword\n    if (_name === $.RETURN_ARG) {\n      _name = returnVar;\n    }\n\n    map[arg.name] = _name;\n  }\n\n  // Build function prototype to invoke the other side\n  let _lookup = (name) => map[name];\n  const _dangling = () => true;\n\n  const inner = body();\n  call(_lookup, _dangling, entry, main.signature, inner);\n  inner.entry = entry;\n\n  // Avoid 'return' keyword\n  map = { return: returnVar };\n  _lookup = (name) => (map[name] != null ? map[name] : name);\n\n  // Build wrapper function for the calling side\n  const outer = body();\n  const wrapper = call(_lookup, _dangling, entry, external.signature, outer);\n  outer.calls = inner.calls;\n  outer.entry = name;\n\n  out.bodies.push(build(inner).code.split(\" {\")[0]);\n  return out.bodies.push(build(outer).code);\n};\n\n// Remove all function prototypes to avoid redefinition errors\nexport function defuse(code) {\n  // Don't try this at home kids\n  const re =\n    /([A-Za-z0-9_]+\\s+)?[A-Za-z0-9_]+\\s+[A-Za-z0-9_]+\\s*\\([^)]*\\)\\s*;\\s*/gm;\n  const strip = (code) => code.replace(re, (m) => \"\");\n\n  // Split into scopes by braces\n  const blocks = code.split(/(?=[{}])/g);\n  let level = 0;\n  for (let i = 0; i < blocks.length; i++) {\n    const b = blocks[i];\n    switch (b[0]) {\n      case \"{\":\n        level++;\n        break;\n      case \"}\":\n        level--;\n        break;\n    }\n\n    // Only mess with top level scope\n    if (level === 0) {\n      // Preprocessor lines will fuck us up. Split on them.\n      const hash = b.split(/^[ \\t]*#/m);\n      for (let j = 0; j < hash.length; j++) {\n        let line = hash[j];\n        if (j > 0) {\n          // Trim off preprocessor directive\n          line = line.split(/\\n/);\n          const head = line.shift();\n          const rest = line.join(\"\\n\");\n\n          // Process rest\n          hash[j] = [head, strip(rest)].join(\"\\n\");\n        } else {\n          // Process entire line\n          hash[j] = strip(line);\n        }\n      }\n\n      // Reassemble\n      blocks[i] = hash.join(\"#\");\n    }\n  }\n\n  return (code = blocks.join(\"\"));\n}\n\n// Remove duplicate uniforms / varyings / attributes\nexport function dedupe(code) {\n  const map = {};\n  const re =\n    /((attribute|uniform|varying)\\s+)[A-Za-z0-9_]+\\s+([A-Za-z0-9_]+)\\s*(\\[[^\\]]*\\]\\s*)?;\\s*/gm;\n  return code.replace(re, function (m, qual, type, name, struct) {\n    if (map[name]) {\n      return \"\";\n    }\n    map[name] = true;\n    return m;\n  });\n}\n\n// Move definitions to top so they compile properly\nexport function hoist(code) {\n  const filter = function (lines, re) {\n    const defs = [];\n    const out = [];\n    for (let line of Array.from(lines)) {\n      const list = line.match(re) ? defs : out;\n      list.push(line);\n    }\n\n    return defs.concat(out);\n  };\n\n  let lines = code.split(\"\\n\");\n\n  // Hoist symbol defines to the top so (re)definitions use the right alias\n  lines = filter(lines, /^#define ([^ ]+ _pg_[0-9]+_|_pg_[0-9]+_ [^ ]+)$/);\n\n  // Hoist extensions\n  lines = filter(lines, /^#extension/);\n\n  return lines.join(\"\\n\");\n}\n","export * from \"./compile\";\nexport * from \"./parse\";\nexport * from \"./generate\";\nexport * from \"./constants\";\n","/*\n * decaffeinate suggestions:\n * DS102: Remove unnecessary code created because of implicit returns\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\nimport { Block } from \"./block\";\nimport * as Factory from \"./factory\";\nimport * as GLSL from \"./glsl\";\nimport * as Graph from \"./graph\";\nimport * as Linker from \"./linker\";\nimport * as Visualize from \"./visualize\";\n\nconst { library, cache } = Factory;\nexport const { visualize, inspect } = Visualize;\nconst { Snippet } = Linker;\n\nconst merge = function (a, b = {}) {\n  const out = {};\n  for (let key in a) {\n    out[key] = b[key] || a[key];\n  }\n  return out;\n};\n\nexport class ShaderGraph {\n  constructor(snippets, config) {\n    if (!(this instanceof ShaderGraph)) {\n      return new ShaderGraph(snippets, config);\n    }\n\n    const defaults = {\n      globalUniforms: false,\n      globalVaryings: true,\n      globalAttributes: true,\n      globals: [],\n      autoInspect: false,\n    };\n\n    this.config = merge(defaults, config);\n    this.fetch = cache(library(GLSL, snippets, Snippet.load));\n  }\n\n  shader(config) {\n    if (config == null) {\n      config = {};\n    }\n    const _config = merge(this.config, config);\n    return new Factory.Factory(GLSL, this.fetch, _config);\n  }\n\n  material(config) {\n    return new Factory.Material(this.shader(config), this.shader(config));\n  }\n\n  inspect(shader) {\n    return ShaderGraph.inspect(shader);\n  }\n  visualize(shader) {\n    return ShaderGraph.visualize(shader);\n  }\n\n  // Static visualization method\n  static inspect(shader) {\n    return inspect(shader);\n  }\n  static visualize(shader) {\n    return visualize(shader);\n  }\n}\n\n// Expose class hierarchy\nShaderGraph.Block = Block;\nShaderGraph.Factory = Factory;\nShaderGraph.GLSL = GLSL;\nShaderGraph.Graph = Graph;\nShaderGraph.Linker = Linker;\nShaderGraph.Visualize = Visualize;\n\nexport function load(snippets, config = {}) {\n  return new ShaderGraph(snippets, config);\n}\n"],"sourceRoot":""}